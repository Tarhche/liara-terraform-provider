// Package file_browser provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package file_browser

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JwtScopes = "jwt.Scopes"
)

// List defines model for list.
type List struct {
	CreateAt  *string `json:"createAt,omitempty"`
	DiskName  *string `json:"diskName,omitempty"`
	Extension *string `json:"extension,omitempty"`
	IsDir     *bool   `json:"isDir,omitempty"`
	IsSymlink *bool   `json:"isSymlink,omitempty"`
	Items     *[]struct {
		CreateAt      *string  `json:"createAt,omitempty"`
		Extension     *string  `json:"extension,omitempty"`
		IsDir         *bool    `json:"isDir,omitempty"`
		IsSymlink     *bool    `json:"isSymlink,omitempty"`
		Mode          *float32 `json:"mode,omitempty"`
		ModifiedAt    *string  `json:"modifiedAt,omitempty"`
		Name          *string  `json:"name,omitempty"`
		Path          *string  `json:"path,omitempty"`
		Size          *float32 `json:"size,omitempty"`
		TargetSymlink *string  `json:"targetSymlink,omitempty"`
		Type          *string  `json:"type,omitempty"`
	} `json:"items,omitempty"`
	Mode       *float32 `json:"mode,omitempty"`
	ModifiedAt *string  `json:"modifiedAt,omitempty"`
	Name       *string  `json:"name,omitempty"`
	NumDirs    *float32 `json:"numDirs,omitempty"`
	NumFiles   *float32 `json:"numFiles,omitempty"`
	Path       *string  `json:"path,omitempty"`
	Size       *float32 `json:"size,omitempty"`
	Sorting    *struct {
		Page          *float32 `json:"page,omitempty"`
		SortDirection *string  `json:"sortDirection,omitempty"`
		SortType      *string  `json:"sortType,omitempty"`
	} `json:"sorting,omitempty"`
	TargetSymlink *string `json:"targetSymlink,omitempty"`
	Type          *string `json:"type,omitempty"`
}

// Search defines model for search.
type Search struct {
	DiskName *string `json:"diskName,omitempty"`
	Items    *[]struct {
		CreateAt      *string  `json:"createAt,omitempty"`
		Extension     *string  `json:"extension,omitempty"`
		IsDir         *bool    `json:"isDir,omitempty"`
		IsSymlink     *bool    `json:"isSymlink,omitempty"`
		Mode          *float32 `json:"mode,omitempty"`
		ModifiedAt    *string  `json:"modifiedAt,omitempty"`
		Name          *string  `json:"name,omitempty"`
		Path          *string  `json:"path,omitempty"`
		Size          *float32 `json:"size,omitempty"`
		TargetSymlink *string  `json:"targetSymlink,omitempty"`
		Type          *string  `json:"type,omitempty"`
	} `json:"items,omitempty"`
	Sorting *struct {
		Page          *float32 `json:"page,omitempty"`
		SortDirection *string  `json:"sortDirection,omitempty"`
		SortType      *string  `json:"sortType,omitempty"`
	} `json:"sorting,omitempty"`
}

// CreateParams defines parameters for Create.
type CreateParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// Type The type of your request. valid values:["file", "dir"]
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Name The name of your file or dir
	Name *string `form:"name,omitempty" json:"name,omitempty"`
}

// CreateLinkParams defines parameters for CreateLink.
type CreateLinkParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// Type The type of your request. valid values:["preview", "download"]
	Type *string `form:"type,omitempty" json:"type,omitempty"`

	// Expire The expire of your link. valid values:["1h", "6h", "1d", "3d", "7d"]
	Expire *string `form:"expire,omitempty" json:"expire,omitempty"`
}

// DeleteParams defines parameters for Delete.
type DeleteParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`
}

// ExtractParams defines parameters for Extract.
type ExtractParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// Output The output path of your request
	Output string `form:"output" json:"output"`

	// Overwrite The overwrite of your request
	Overwrite *string `form:"overwrite,omitempty" json:"overwrite,omitempty"`
}

// GetListParams defines parameters for GetList.
type GetListParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// SortType The sortType for pagination. valid values:["name", "size", "modTime"]
	SortType *string `form:"sortType,omitempty" json:"sortType,omitempty"`

	// SortDirection The sortDirection for pagination. valid values:["asc", "desc"]
	SortDirection *string `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// Page The page for pagination. min 1
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`
}

// RenameParams defines parameters for Rename.
type RenameParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// NewName The newName of your path
	NewName *string `form:"newName,omitempty" json:"newName,omitempty"`
}

// SearchParams defines parameters for Search.
type SearchParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// SortType The sortType for pagination. valid values:["name", "size", "modTime"]
	SortType *string `form:"sortType,omitempty" json:"sortType,omitempty"`

	// SortDirection The sortDirection for pagination. valid values:["asc", "desc"]
	SortDirection *string `form:"sortDirection,omitempty" json:"sortDirection,omitempty"`

	// Page The page for pagination. min 1
	Page *float32 `form:"page,omitempty" json:"page,omitempty"`

	// TargetPath The targetPath of your disk
	TargetPath *string `form:"targetPath,omitempty" json:"targetPath,omitempty"`
}

// ServeParams defines parameters for Serve.
type ServeParams struct {
	// Path The path of createLink query route
	Path string `form:"path" json:"path"`

	// Type The path of createLink query route
	Type string `form:"type" json:"type"`

	// Token The path of createLink query route
	Token string `form:"token" json:"token"`
}

// UploadMultipartBody defines parameters for Upload.
type UploadMultipartBody struct {
	File openapi_types.File `json:"file"`
}

// UploadParams defines parameters for Upload.
type UploadParams struct {
	// Path The path of your disk
	Path string `form:"path" json:"path"`

	// Overwrite The overwrite of your request
	Overwrite *string `form:"overwrite,omitempty" json:"overwrite,omitempty"`
}

// UploadMultipartRequestBody defines body for Upload for multipart/form-data ContentType.
type UploadMultipartRequestBody UploadMultipartBody

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// Create request
	Create(ctx context.Context, projectID string, diskName string, params *CreateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateLink request
	CreateLink(ctx context.Context, projectID string, diskName string, params *CreateLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Delete request
	Delete(ctx context.Context, projectID string, diskName string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Extract request
	Extract(ctx context.Context, projectID string, diskName string, params *ExtractParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetList request
	GetList(ctx context.Context, projectID string, diskName string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Rename request
	Rename(ctx context.Context, projectID string, diskName string, params *RenameParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Search request
	Search(ctx context.Context, projectID string, diskName string, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// Serve request
	Serve(ctx context.Context, projectID string, diskName string, params *ServeParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadWithBody request with any body
	UploadWithBody(ctx context.Context, projectID string, diskName string, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) Create(ctx context.Context, projectID string, diskName string, params *CreateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateLink(ctx context.Context, projectID string, diskName string, params *CreateLinkParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateLinkRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Delete(ctx context.Context, projectID string, diskName string, params *DeleteParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Extract(ctx context.Context, projectID string, diskName string, params *ExtractParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewExtractRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetList(ctx context.Context, projectID string, diskName string, params *GetListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Rename(ctx context.Context, projectID string, diskName string, params *RenameParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRenameRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Search(ctx context.Context, projectID string, diskName string, params *SearchParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSearchRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) Serve(ctx context.Context, projectID string, diskName string, params *ServeParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewServeRequest(c.Server, projectID, diskName, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadWithBody(ctx context.Context, projectID string, diskName string, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadRequestWithBody(c.Server, projectID, diskName, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewCreateRequest generates requests for Create
func NewCreateRequest(server string, projectID string, diskName string, params *CreateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/create", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateLinkRequest generates requests for CreateLink
func NewCreateLinkRequest(server string, projectID string, diskName string, params *CreateLinkParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/createLink", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Type != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, *params.Type); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Expire != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "expire", runtime.ParamLocationQuery, *params.Expire); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRequest generates requests for Delete
func NewDeleteRequest(server string, projectID string, diskName string, params *DeleteParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/delete", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewExtractRequest generates requests for Extract
func NewExtractRequest(server string, projectID string, diskName string, params *ExtractParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/extract", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "output", runtime.ParamLocationQuery, params.Output); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListRequest generates requests for GetList
func NewGetListRequest(server string, projectID string, diskName string, params *GetListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/list", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortType", runtime.ParamLocationQuery, *params.SortType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRenameRequest generates requests for Rename
func NewRenameRequest(server string, projectID string, diskName string, params *RenameParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/rename", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.NewName != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "newName", runtime.ParamLocationQuery, *params.NewName); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewSearchRequest generates requests for Search
func NewSearchRequest(server string, projectID string, diskName string, params *SearchParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/search", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.SortType != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortType", runtime.ParamLocationQuery, *params.SortType); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.SortDirection != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "sortDirection", runtime.ParamLocationQuery, *params.SortDirection); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Page != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, *params.Page); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TargetPath != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "targetPath", runtime.ParamLocationQuery, *params.TargetPath); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewServeRequest generates requests for Serve
func NewServeRequest(server string, projectID string, diskName string, params *ServeParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/serve", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "type", runtime.ParamLocationQuery, params.Type); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "token", runtime.ParamLocationQuery, params.Token); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadRequestWithBody generates requests for Upload with any type of body
func NewUploadRequestWithBody(server string, projectID string, diskName string, params *UploadParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "projectID", runtime.ParamLocationPath, projectID)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "diskName", runtime.ParamLocationPath, diskName)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/upload", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "path", runtime.ParamLocationQuery, params.Path); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Overwrite != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "overwrite", runtime.ParamLocationQuery, *params.Overwrite); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// CreateWithResponse request
	CreateWithResponse(ctx context.Context, projectID string, diskName string, params *CreateParams, reqEditors ...RequestEditorFn) (*CreateResp, error)

	// CreateLinkWithResponse request
	CreateLinkWithResponse(ctx context.Context, projectID string, diskName string, params *CreateLinkParams, reqEditors ...RequestEditorFn) (*CreateLinkResp, error)

	// DeleteWithResponse request
	DeleteWithResponse(ctx context.Context, projectID string, diskName string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResp, error)

	// ExtractWithResponse request
	ExtractWithResponse(ctx context.Context, projectID string, diskName string, params *ExtractParams, reqEditors ...RequestEditorFn) (*ExtractResp, error)

	// GetListWithResponse request
	GetListWithResponse(ctx context.Context, projectID string, diskName string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResp, error)

	// RenameWithResponse request
	RenameWithResponse(ctx context.Context, projectID string, diskName string, params *RenameParams, reqEditors ...RequestEditorFn) (*RenameResp, error)

	// SearchWithResponse request
	SearchWithResponse(ctx context.Context, projectID string, diskName string, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResp, error)

	// ServeWithResponse request
	ServeWithResponse(ctx context.Context, projectID string, diskName string, params *ServeParams, reqEditors ...RequestEditorFn) (*ServeResp, error)

	// UploadWithBodyWithResponse request with any body
	UploadWithBodyWithResponse(ctx context.Context, projectID string, diskName string, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadResp, error)
}

type CreateResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateLinkResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Queries *struct {
			Path  *string `json:"path,omitempty"`
			Token *string `json:"token,omitempty"`
			Type  *string `json:"type,omitempty"`
		} `json:"queries,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateLinkResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateLinkResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ExtractResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ExtractResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ExtractResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *List
}

// Status returns HTTPResponse.Status
func (r GetListResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RenameResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RenameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RenameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SearchResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Search
}

// Status returns HTTPResponse.Status
func (r SearchResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SearchResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ServeResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ServeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ServeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r UploadResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// CreateWithResponse request returning *CreateResp
func (c *ClientWithResponses) CreateWithResponse(ctx context.Context, projectID string, diskName string, params *CreateParams, reqEditors ...RequestEditorFn) (*CreateResp, error) {
	rsp, err := c.Create(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateResp(rsp)
}

// CreateLinkWithResponse request returning *CreateLinkResp
func (c *ClientWithResponses) CreateLinkWithResponse(ctx context.Context, projectID string, diskName string, params *CreateLinkParams, reqEditors ...RequestEditorFn) (*CreateLinkResp, error) {
	rsp, err := c.CreateLink(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateLinkResp(rsp)
}

// DeleteWithResponse request returning *DeleteResp
func (c *ClientWithResponses) DeleteWithResponse(ctx context.Context, projectID string, diskName string, params *DeleteParams, reqEditors ...RequestEditorFn) (*DeleteResp, error) {
	rsp, err := c.Delete(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteResp(rsp)
}

// ExtractWithResponse request returning *ExtractResp
func (c *ClientWithResponses) ExtractWithResponse(ctx context.Context, projectID string, diskName string, params *ExtractParams, reqEditors ...RequestEditorFn) (*ExtractResp, error) {
	rsp, err := c.Extract(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseExtractResp(rsp)
}

// GetListWithResponse request returning *GetListResp
func (c *ClientWithResponses) GetListWithResponse(ctx context.Context, projectID string, diskName string, params *GetListParams, reqEditors ...RequestEditorFn) (*GetListResp, error) {
	rsp, err := c.GetList(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListResp(rsp)
}

// RenameWithResponse request returning *RenameResp
func (c *ClientWithResponses) RenameWithResponse(ctx context.Context, projectID string, diskName string, params *RenameParams, reqEditors ...RequestEditorFn) (*RenameResp, error) {
	rsp, err := c.Rename(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRenameResp(rsp)
}

// SearchWithResponse request returning *SearchResp
func (c *ClientWithResponses) SearchWithResponse(ctx context.Context, projectID string, diskName string, params *SearchParams, reqEditors ...RequestEditorFn) (*SearchResp, error) {
	rsp, err := c.Search(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSearchResp(rsp)
}

// ServeWithResponse request returning *ServeResp
func (c *ClientWithResponses) ServeWithResponse(ctx context.Context, projectID string, diskName string, params *ServeParams, reqEditors ...RequestEditorFn) (*ServeResp, error) {
	rsp, err := c.Serve(ctx, projectID, diskName, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseServeResp(rsp)
}

// UploadWithBodyWithResponse request with arbitrary body returning *UploadResp
func (c *ClientWithResponses) UploadWithBodyWithResponse(ctx context.Context, projectID string, diskName string, params *UploadParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadResp, error) {
	rsp, err := c.UploadWithBody(ctx, projectID, diskName, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadResp(rsp)
}

// ParseCreateResp parses an HTTP response from a CreateWithResponse call
func ParseCreateResp(rsp *http.Response) (*CreateResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCreateLinkResp parses an HTTP response from a CreateLinkWithResponse call
func ParseCreateLinkResp(rsp *http.Response) (*CreateLinkResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateLinkResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Queries *struct {
				Path  *string `json:"path,omitempty"`
				Token *string `json:"token,omitempty"`
				Type  *string `json:"type,omitempty"`
			} `json:"queries,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseDeleteResp parses an HTTP response from a DeleteWithResponse call
func ParseDeleteResp(rsp *http.Response) (*DeleteResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseExtractResp parses an HTTP response from a ExtractWithResponse call
func ParseExtractResp(rsp *http.Response) (*ExtractResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ExtractResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetListResp parses an HTTP response from a GetListWithResponse call
func ParseGetListResp(rsp *http.Response) (*GetListResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest List
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRenameResp parses an HTTP response from a RenameWithResponse call
func ParseRenameResp(rsp *http.Response) (*RenameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RenameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseSearchResp parses an HTTP response from a SearchWithResponse call
func ParseSearchResp(rsp *http.Response) (*SearchResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SearchResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Search
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseServeResp parses an HTTP response from a ServeWithResponse call
func ParseServeResp(rsp *http.Response) (*ServeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ServeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUploadResp parses an HTTP response from a UploadWithResponse call
func ParseUploadResp(rsp *http.Response) (*UploadResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xa227bOBN+FYL9L1MfevgX8NUm67YotlsUm/YqMVBaGtvTSiQ7pHxo4HdfDClbdiRn",
	"m8RuFqlvLFlD8RsO5xuOhrySicmt0aC9k70r6ZIJ5CrcZug8Xy0ZC+QRwtOEQHk4DRK/sCB70nlCPZbL",
	"E5mi+/pe5dAohLkH7dDoRim6PtKGZGhMBkpH0fkiz1B/3SH2kAfV1je30PhQSuUm3bSCLvIhUCnAEUK6",
	"Qx+9y3pW+UmjwOH3ZiSvaAy+rmX1anxQE6wl0gy/QOKrplIRqcVBxqeLvI/kGvvURf4aM2gW3t4wzpDn",
	"NjVPsWq8+40+EiR+l6dwi4+3MOc+58aBomRSH86NbDyy5gFY8+Ce1/jEQVIQ+sU5x/6oz5dZMHQKLiG0",
	"EVu+0h5I+AkIb76CFjP0k/D38xkoAuqJz8ISjHB+IqA1bolLGQVCDZMUus+ev3h5KVtCPJEnErnHCagU",
	"SK4mUJ4WfmIIv6uAWNnP4p+wkMtl6XqkVdY3iaur+Bp1KkzhRW4IhBry7TtUpAQHEHFGZuYCYEEZ43tv",
	"Xa/dTk3iWhm3ayG1mTeuPcIMng7jC+3gu3pkAjOM9ioJ9oFcIffjCmsN+d9XXVQjCk9qeOt2vGZuD8CQ",
	"yJVWY9RjwSo4gVosTEEiqMVGQZ9x1/VxidMPb0XfJEUO2qtowilQJKrstjqtDiMaC1pZlD35vNVpdWWk",
	"SbBme9ptWzLsGq59Vd697S9Lm1ytQsqyHeND8F0T8wT25zBxb1PZk39EOfdNKgcPHNsvrs/XxwkITIUZ",
	"xSGWgCv3COxdm3KtjTyRBN8KJEhlz1MBJ2Xa0kiBJkjucQ3KY2pGXAfQewNyv42A3wqgxcYYI/490bjR",
	"Go37AudbYqoyTPm3ANe7uJTsXZfyRFzKFOlSDnaoFBDvZ2FGEoYHTjtAdLTybpABG8VZo10MUM863Tr7",
	"z4skAedGRSbWzsgO/6LTqTc+U+nKNrFNQ4d/oXNMRFX4CWiPyUaXL+rNT60VqQEntPEC5ui8a3Hjl034",
	"nzTMLSQeUgFEhmIoLvJc0WLNn03TcSBgtldBzKsxk0r2Q2QYcAe3JfC7cpW7icShzZHI/1kiW4Ipwqzk",
	"spnpzKh034SGuUWqlOHsqK5JdxKV+H957abx+ry8/naDWhHgLkGAF2TQwX2VtVnJ0vYXFzOmqr/tnIvx",
	"V+nXtWRsR9IY0p775YQNT2o5wCMMY+wuYmTKpWC/gSyFDGImUt1th7F+fH4MYYcNYXV6Pnvca3T0qwOu",
	"0TD3VH5qNC/Qr8oGR9d+gNXZFN4Wfht05a3NuPGNPSBPgWaEHn4Ud9V+a3lNYaSKzHP6baqP7V835S7J",
	"dIg1alVLH0MDid+Af4fuSOIHIfGqfBayE6vGqMPE1HNbRo1ZrMPv5V1u0o/Ij3cltevi3J30Whf+/lU5",
	"5ZIy/Qe+u0mdqpp4h5kZ1+2UoxbdnVM0bhz6qr7ZEGM6t8ro/0cwkj35pF3tYrXLLazIuUeeXr8BL3ic",
	"YkQm32fAIljV1JsTj7+hLNkcQ9ZPD1kaZu83R1j22lhXi02PpbVN0kTfPWDaXm3INa7351F85M5xuf/F",
	"lvvmImfYcf3wg25Qtb5lUNtfYlHS+5GnFjFKHTRK0hRuCJIsPcbIrRhZ7dmIQAtBpggf9YcLmHeCLrcY",
	"HgQ61OjvV7bsPO78J1ArEnvfnw2FzYxKd382fIryI60folz504qGodczky6uLbl5kXm0inx7ZCh/miqv",
	"btqgYw8NV0O5YsQhahU0rG+zVba5iO8NGjbalr/al06k248WNDeOggVShkNgFwOe07BWl1zdPsp0xZ2X",
	"x6SeFpQt5YmcKkI1zKpZ3JBv+9Crucptxh523V/RxXxXoBPKORxrSMVwEc6bsTaYAAeGKaZALZ7cwXpE",
	"tXNrU6CFn4Q5CCfCgvNvHZxCLfrl8arS++Pf5WD5TwAAAP//b5pCkiItAAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
