// Package paas provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.0 DO NOT EDIT.
package paas

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	JwtScopes = "jwt.Scopes"
)

// Applets defines model for Applets.
type Applets struct {
	Applets *[]struct {
		// Id The id of applet
		Id *string `json:"id,omitempty"`

		// Name The name of applet
		Name *string `json:"name,omitempty"`

		// Reason The reason of applet
		Reason *string `json:"reason,omitempty"`

		// Release The release of applet
		Release *struct {
			// ReleaseID The releaseID of release
			ReleaseID *string `json:"releaseID,omitempty"`

			// Tag The tag of release
			Tag *string `json:"tag,omitempty"`
		} `json:"release,omitempty"`

		// State The state of applet
		State *string `json:"state,omitempty"`

		// Timestamp The timestamp of applet
		Timestamp *string `json:"timestamp,omitempty"`
	} `json:"applets,omitempty"`
}

// CheckDomain defines model for CheckDomain.
type CheckDomain struct {
	Domain *struct {
		CNameRecord           *string  `json:"CNameRecord,omitempty"`
		UnderscoreUnderscoreV *float32 `json:"__v,omitempty"`
		UnderscoreId          *string  `json:"_id,omitempty"`
		CertificatesStatus    *string  `json:"certificatesStatus,omitempty"`
		CreatedAt             *string  `json:"created_at,omitempty"`
		IssuedAt              *string  `json:"issuedAt,omitempty"`
		Name                  *string  `json:"name,omitempty"`
		Project               *struct {
			UnderscoreId *string `json:"_id,omitempty"`
			ProjectId    *string `json:"project_id,omitempty"`
		} `json:"project,omitempty"`
		PunycodeName     *string  `json:"punycodeName,omitempty"`
		RedirectStatus   *float32 `json:"redirectStatus,omitempty"`
		RedirectTo       *string  `json:"redirectTo,omitempty"`
		Status           *string  `json:"status,omitempty"`
		Type             *string  `json:"type,omitempty"`
		UpdatedAt        *string  `json:"updated_at,omitempty"`
		User             *string  `json:"user,omitempty"`
		VerificationCode *string  `json:"verificationCode,omitempty"`
	} `json:"domain,omitempty"`
}

// CreateApp defines model for Create-app.
type CreateApp struct {
	// Name The name of app that you want to create
	Name *string `json:"name,omitempty"`

	// Network For project
	Network *string `json:"network,omitempty"`

	// PlanID The plan of app that you want to create
	PlanID *string `json:"planID,omitempty"`

	// Platform The platform of app that you want to create
	Platform *string `json:"platform,omitempty"`

	// ReadOnlyRootFilesystem For filesystem
	ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`
}

// DeployReleases defines model for Deploy-releases.
type DeployReleases struct {
	// Port The port of your app
	Port *float32 `json:"port,omitempty"`

	// SourceID The id of Deployed sources
	SourceID *string `json:"sourceID,omitempty"`

	// Type The platform of your app
	Type *string `json:"type,omitempty"`
}

// Domains defines model for Domains.
type Domains struct {
	Domains *[]struct {
		// CNameRecord The CNameRecord of domain
		CNameRecord *string `json:"CNameRecord,omitempty"`

		// UnderscoreId The id of domain
		UnderscoreId *string `json:"_id,omitempty"`

		// CertificatesStatus The certificatesStatus of domain
		CertificatesStatus *string `json:"certificatesStatus,omitempty"`

		// CreatedAt The created_at of domain
		CreatedAt *string `json:"created_at,omitempty"`

		// Name The name of domain
		Name *string `json:"name,omitempty"`

		// Project The type of domain
		Project *struct {
			// UnderscoreId The id of project
			UnderscoreId *string `json:"_id,omitempty"`

			// ProjectId The name of project
			ProjectId *string `json:"project_id,omitempty"`
		} `json:"project,omitempty"`

		// RedirectStatus The redirectStatus of domain
		RedirectStatus *float32 `json:"redirectStatus,omitempty"`

		// RedirectTo The redirectTo of domain
		RedirectTo *string `json:"redirectTo,omitempty"`

		// Status The status of domain
		Status *string `json:"status,omitempty"`

		// Type The type of domain
		Type *string `json:"type,omitempty"`
	} `json:"domains,omitempty"`
}

// GetDiskBackup defines model for Get-disk-backup.
type GetDiskBackup struct {
	Backups *[]struct {
		Etag         *string  `json:"etag,omitempty"`
		LastModified *string  `json:"lastModified,omitempty"`
		Name         *string  `json:"name,omitempty"`
		Size         *float32 `json:"size,omitempty"`
	} `json:"backups,omitempty"`
}

// GetDisks defines model for Get-disks.
type GetDisks struct {
	Disks *[]struct {
		UnderscoreId *string `json:"_id,omitempty"`
		CreatedAt    *string `json:"createdAt,omitempty"`
		Name         *string `json:"name,omitempty"`
		Size         *int    `json:"size,omitempty"`
		UpdatedAt    *string `json:"updatedAt,omitempty"`
	} `json:"disks,omitempty"`
	Mounts *[]struct {
		MountedTo *string `json:"mountedTo,omitempty"`
		Name      *string `json:"name,omitempty"`
	} `json:"mounts,omitempty"`
}

// Logs defines model for Logs.
type Logs = []struct {
	Datetime *string `json:"datetime,omitempty"`
	Message  *string `json:"message,omitempty"`
	Type     *string `json:"type,omitempty"`
}

// ProjectAllDetails defines model for ProjectAllDetails.
type ProjectAllDetails struct {
	Project *struct {
		// UnderscoreId The id of project
		UnderscoreId *string `json:"_id,omitempty"`

		// CreatedAt The time to create of project
		CreatedAt *string `json:"created_at,omitempty"`

		// DefaultSubdomain The defaultSubdomain status of project
		DefaultSubdomain *bool `json:"defaultSubdomain,omitempty"`

		// Envs The envs of project
		Envs *[]struct {
			UnderscoreId *string `json:"_id,omitempty"`
			Encrypted    *bool   `json:"encrypted,omitempty"`
			Key          *string `json:"key,omitempty"`
			Value        *string `json:"value,omitempty"`
		} `json:"envs,omitempty"`

		// FixedIPStatus The fixedIPStatus of project
		FixedIPStatus *string `json:"fixedIPStatus,omitempty"`

		// HourlyPrice The hourlyPrice of project
		HourlyPrice *float32 `json:"hourlyPrice,omitempty"`

		// IsDeployed The deployment status of project
		IsDeployed *bool `json:"isDeployed,omitempty"`

		// Node The node of project
		Node *struct {
			IP           *string `json:"IP,omitempty"`
			UnderscoreId *string `json:"_id,omitempty"`
		} `json:"node,omitempty"`

		// PlanID The plan of project
		PlanID *string `json:"planID,omitempty"`

		// ProjectId The name of project
		ProjectId *string `json:"project_id,omitempty"`

		// ReadOnlyRootFilesystem The readOnlyRootFilesystem of project
		ReadOnlyRootFilesystem *bool `json:"readOnlyRootFilesystem,omitempty"`

		// ReservedDiskSpace The count reservedDiskSpace of project
		ReservedDiskSpace *float32 `json:"reservedDiskSpace,omitempty"`

		// Scale The being on of project
		Scale *float32 `json:"scale,omitempty"`

		// Status The status of project
		Status *string `json:"status,omitempty"`

		// Type The platform of project
		Type *string `json:"type,omitempty"`

		// ZeroDowntime The zeroDowntime status of project
		ZeroDowntime *bool `json:"zeroDowntime,omitempty"`
	} `json:"project,omitempty"`
}

// Projects defines model for Projects.
type Projects struct {
	Projects *[]struct {
		// UnderscoreId The id of project
		UnderscoreId *string `json:"_id,omitempty"`

		// CreatedAt The time to create the project
		CreatedAt *string `json:"created_at,omitempty"`

		// IsDeployed The project deployment status
		IsDeployed *bool `json:"isDeployed,omitempty"`

		// PlanID The plan of project
		PlanID *string `json:"planID,omitempty"`

		// ProjectId The name of project
		ProjectId *string `json:"project_id,omitempty"`

		// Scale The being on of project
		Scale *float32 `json:"scale,omitempty"`

		// Status The status of project
		Status *string `json:"status,omitempty"`

		// Type The platform of project
		Type *string `json:"type,omitempty"`
	} `json:"projects,omitempty"`
}

// Releases defines model for Releases.
type Releases struct {
	// CurrentRelease The currentRelease of releases
	CurrentRelease *string `json:"currentRelease,omitempty"`
	Platform       *string `json:"platform,omitempty"`

	// ReadyReleasesCount The total of releases
	ReadyReleasesCount *float32 `json:"readyReleasesCount,omitempty"`

	// Releases The total of releases
	Releases *[]struct {
		// UnderscoreId The id of release
		UnderscoreId *string `json:"_id,omitempty"`

		// Client The client of release
		Client *string `json:"client,omitempty"`

		// CreatedAt The createdAt of release
		CreatedAt *string `json:"createdAt,omitempty"`

		// FinishedAt The finishedAt of release
		FinishedAt *string `json:"finishedAt,omitempty"`
		GitInfo    *struct {
			Author *struct {
				Email *string `json:"email"`
				Name  *string `json:"name"`
			} `json:"author,omitempty"`
			Branch      *string    `json:"branch"`
			Commit      *string    `json:"commit"`
			CommittedAt *time.Time `json:"committedAt"`
			Message     *string    `json:"message"`
			Remote      *string    `json:"remote"`
			Tags        *[]string  `json:"tags,omitempty"`
		} `json:"gitInfo,omitempty"`

		// ImageName The imageName of release
		ImageName *string `json:"imageName,omitempty"`

		// Port The port of release
		Port *float32 `json:"port,omitempty"`

		// ProjectType The projectType of release
		ProjectType *string `json:"projectType,omitempty"`

		// SourceAvailable The sourceAvailable of release
		SourceAvailable *bool `json:"sourceAvailable,omitempty"`

		// State The state of release
		State *string `json:"state,omitempty"`

		// Tag The tag of release
		Tag *string `json:"tag,omitempty"`

		// Type The type of release
		Type *string `json:"type,omitempty"`
	} `json:"releases,omitempty"`

	// Total The total of releases
	Total *float32 `json:"total,omitempty"`
}

// Reports defines model for Reports.
type Reports struct {
	End    *float32 `json:"end,omitempty"`
	Result *[]struct {
		Applet *string                         `json:"applet,omitempty"`
		Values *[][]Reports_Result_Values_Item `json:"values,omitempty"`
	} `json:"result,omitempty"`
}

// ReportsResultValues0 defines model for .
type ReportsResultValues0 = float32

// ReportsResultValues1 defines model for .
type ReportsResultValues1 = string

// Reports_Result_Values_Item defines model for Reports.Result.Values.Item.
type Reports_Result_Values_Item struct {
	union json.RawMessage
}

// UpdateEnvs defines model for Update-envs.
type UpdateEnvs struct {
	// Project The name of your app for update envs
	Project *string `json:"project,omitempty"`

	// Variables The envs for update
	Variables *[]struct {
		// Key The name of your env
		Key *string `json:"key,omitempty"`

		// Value The value of your env
		Value *string `json:"value,omitempty"`
	} `json:"variables,omitempty"`
}

// GetAppDomainsParams defines parameters for GetAppDomains.
type GetAppDomainsParams struct {
	// Project The name of your app
	Project string `form:"project" json:"project"`
}

// CreateAppDomainJSONBody defines parameters for CreateAppDomain.
type CreateAppDomainJSONBody struct {
	Name    string `json:"name"`
	Project string `json:"project"`
	Type    string `json:"type"`
}

// EnableSslJSONBody defines parameters for EnableSsl.
type EnableSslJSONBody struct {
	Domain string `json:"domain"`
}

// SetAppDomainJSONBody defines parameters for SetAppDomain.
type SetAppDomainJSONBody struct {
	DomainID  string `json:"domainID"`
	ProjectID string `json:"projectID"`
}

// RedirectDomainJSONBody defines parameters for RedirectDomain.
type RedirectDomainJSONBody struct {
	// RedirectStatus 302 or 301
	RedirectStatus float32 `json:"redirectStatus"`
	RedirectTo     string  `json:"redirectTo"`
}

// TurnAppJSONBody defines parameters for TurnApp.
type TurnAppJSONBody struct {
	Scale float32 `json:"scale"`
}

// CreateDiskJSONBody defines parameters for CreateDisk.
type CreateDiskJSONBody struct {
	Name string `json:"name"`
	Size string `json:"size"`
}

// CreateFtpJSONBody defines parameters for CreateFtp.
type CreateFtpJSONBody struct {
	ReadOnly bool   `json:"readOnly"`
	Username string `json:"username"`
}

// ResizeDiskJSONBody defines parameters for ResizeDisk.
type ResizeDiskJSONBody struct {
	Size string `json:"size"`
}

// GetAppEventsParams defines parameters for GetAppEvents.
type GetAppEventsParams struct {
	// Search Show events based on search query
	Search *string `form:"search,omitempty" json:"search,omitempty"`

	// Start start timestamp
	Start *float32 `form:"start,omitempty" json:"start,omitempty"`

	// End end timestamp
	End *float32 `form:"end,omitempty" json:"end,omitempty"`
}

// GetAppLogsParams defines parameters for GetAppLogs.
type GetAppLogsParams struct {
	// Since Show logs since timestamp
	Since string `form:"since" json:"since"`
}

// GetAppCpuReportsParams defines parameters for GetAppCpuReports.
type GetAppCpuReportsParams struct {
	// Since The since of your cpu reports
	Since float32 `form:"since" json:"since"`
}

// GetAppMemoryReportsParams defines parameters for GetAppMemoryReports.
type GetAppMemoryReportsParams struct {
	// Since The since of your memory reports
	Since float32 `form:"since" json:"since"`
}

// GetAppNetworkReceiveReportsParams defines parameters for GetAppNetworkReceiveReports.
type GetAppNetworkReceiveReportsParams struct {
	// Since The since of your network-receive reports
	Since float32 `form:"since" json:"since"`
}

// GetNetworkTransmitReportsParams defines parameters for GetNetworkTransmitReports.
type GetNetworkTransmitReportsParams struct {
	// Since The since of your network-transmit reports
	Since float32 `form:"since" json:"since"`
}

// GetAppReleasesParams defines parameters for GetAppReleases.
type GetAppReleasesParams struct {
	// Page The page of your releases
	Page float32 `form:"page" json:"page"`

	// Count The count of your releases
	Count float32 `form:"count" json:"count"`
}

// ChangePlanJSONBody defines parameters for ChangePlan.
type ChangePlanJSONBody struct {
	PlanID string `json:"planID"`
}

// SourcesDeployMultipartBody defines parameters for SourcesDeploy.
type SourcesDeployMultipartBody struct {
	// File The .gz file to deploy
	File openapi_types.File `json:"file"`
}

// CreateAppDomainJSONRequestBody defines body for CreateAppDomain for application/json ContentType.
type CreateAppDomainJSONRequestBody CreateAppDomainJSONBody

// EnableSslJSONRequestBody defines body for EnableSsl for application/json ContentType.
type EnableSslJSONRequestBody EnableSslJSONBody

// SetAppDomainJSONRequestBody defines body for SetAppDomain for application/json ContentType.
type SetAppDomainJSONRequestBody SetAppDomainJSONBody

// RedirectDomainJSONRequestBody defines body for RedirectDomain for application/json ContentType.
type RedirectDomainJSONRequestBody RedirectDomainJSONBody

// CreateAppJSONRequestBody defines body for CreateApp for application/json ContentType.
type CreateAppJSONRequestBody = CreateApp

// UpdateEnvsJSONRequestBody defines body for UpdateEnvs for application/json ContentType.
type UpdateEnvsJSONRequestBody = UpdateEnvs

// TurnAppJSONRequestBody defines body for TurnApp for application/json ContentType.
type TurnAppJSONRequestBody TurnAppJSONBody

// CreateDiskJSONRequestBody defines body for CreateDisk for application/json ContentType.
type CreateDiskJSONRequestBody CreateDiskJSONBody

// CreateFtpJSONRequestBody defines body for CreateFtp for application/json ContentType.
type CreateFtpJSONRequestBody CreateFtpJSONBody

// ResizeDiskJSONRequestBody defines body for ResizeDisk for application/json ContentType.
type ResizeDiskJSONRequestBody ResizeDiskJSONBody

// ChangePlanJSONRequestBody defines body for ChangePlan for application/json ContentType.
type ChangePlanJSONRequestBody ChangePlanJSONBody

// ReleasesDeployJSONRequestBody defines body for ReleasesDeploy for application/json ContentType.
type ReleasesDeployJSONRequestBody = DeployReleases

// SourcesDeployMultipartRequestBody defines body for SourcesDeploy for multipart/form-data ContentType.
type SourcesDeployMultipartRequestBody SourcesDeployMultipartBody

// AsReportsResultValues0 returns the union data inside the Reports_Result_Values_Item as a ReportsResultValues0
func (t Reports_Result_Values_Item) AsReportsResultValues0() (ReportsResultValues0, error) {
	var body ReportsResultValues0
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportsResultValues0 overwrites any union data inside the Reports_Result_Values_Item as the provided ReportsResultValues0
func (t *Reports_Result_Values_Item) FromReportsResultValues0(v ReportsResultValues0) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportsResultValues0 performs a merge with any union data inside the Reports_Result_Values_Item, using the provided ReportsResultValues0
func (t *Reports_Result_Values_Item) MergeReportsResultValues0(v ReportsResultValues0) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsReportsResultValues1 returns the union data inside the Reports_Result_Values_Item as a ReportsResultValues1
func (t Reports_Result_Values_Item) AsReportsResultValues1() (ReportsResultValues1, error) {
	var body ReportsResultValues1
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromReportsResultValues1 overwrites any union data inside the Reports_Result_Values_Item as the provided ReportsResultValues1
func (t *Reports_Result_Values_Item) FromReportsResultValues1(v ReportsResultValues1) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeReportsResultValues1 performs a merge with any union data inside the Reports_Result_Values_Item, using the provided ReportsResultValues1
func (t *Reports_Result_Values_Item) MergeReportsResultValues1(v ReportsResultValues1) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Reports_Result_Values_Item) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Reports_Result_Values_Item) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAppDomains request
	GetAppDomains(ctx context.Context, params *GetAppDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppDomainWithBody request with any body
	CreateAppDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateAppDomain(ctx context.Context, body CreateAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EnableSslWithBody request with any body
	EnableSslWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EnableSsl(ctx context.Context, body EnableSslJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SetAppDomainWithBody request with any body
	SetAppDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	SetAppDomain(ctx context.Context, body SetAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDomain request
	DeleteDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CheckDomain request
	CheckDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RedirectDomainWithBody request with any body
	RedirectDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	RedirectDomain(ctx context.Context, id string, body RedirectDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DisableSsl request
	DisableSsl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteFtp request
	DeleteFtp(ctx context.Context, fname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApps request
	GetApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateAppWithBody request with any body
	CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UpdateEnvsWithBody request with any body
	UpdateEnvsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UpdateEnvs(ctx context.Context, body UpdateEnvsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DefaultSubdomain request
	DefaultSubdomain(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetDisks request
	GetDisks(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DownloadBackup request
	DownloadBackup(ctx context.Context, id string, dname string, bname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteDisk request
	DeleteDisk(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetBackups request
	GetBackups(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateBackup request
	CreateBackup(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// IpStatic request
	IpStatic(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReadOnly request
	ReadOnly(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ZeroDowntime request
	ZeroDowntime(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAppByName request
	DeleteAppByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppByName request
	GetAppByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// RestartApp request
	RestartApp(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// TurnAppWithBody request with any body
	TurnAppWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	TurnApp(ctx context.Context, name string, body TurnAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppApplets request
	GetAppApplets(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateDiskWithBody request with any body
	CreateDiskWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateDisk(ctx context.Context, name string, body CreateDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetFtps request
	GetFtps(ctx context.Context, name string, dname string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CreateFtpWithBody request with any body
	CreateFtpWithBody(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CreateFtp(ctx context.Context, name string, dname string, body CreateFtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ResizeDiskWithBody request with any body
	ResizeDiskWithBody(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ResizeDisk(ctx context.Context, name string, dname string, body ResizeDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppEvents request
	GetAppEvents(ctx context.Context, name string, params *GetAppEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppLogs request
	GetAppLogs(ctx context.Context, name string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppCpuReports request
	GetAppCpuReports(ctx context.Context, name string, params *GetAppCpuReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppMemoryReports request
	GetAppMemoryReports(ctx context.Context, name string, params *GetAppMemoryReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppNetworkReceiveReports request
	GetAppNetworkReceiveReports(ctx context.Context, name string, params *GetAppNetworkReceiveReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetNetworkTransmitReports request
	GetNetworkTransmitReports(ctx context.Context, name string, params *GetNetworkTransmitReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppSummaryReports request
	GetAppSummaryReports(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAppReleases request
	GetAppReleases(ctx context.Context, name string, params *GetAppReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ChangePlanWithBody request with any body
	ChangePlanWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ChangePlan(ctx context.Context, name string, body ChangePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ReleasesDeployWithBody request with any body
	ReleasesDeployWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ReleasesDeploy(ctx context.Context, name string, body ReleasesDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// SourcesDeployWithBody request with any body
	SourcesDeployWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAppDomains(ctx context.Context, params *GetAppDomainsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppDomainsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppDomain(ctx context.Context, body CreateAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableSslWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableSslRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EnableSsl(ctx context.Context, body EnableSslJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEnableSslRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppDomainWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppDomainRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SetAppDomain(ctx context.Context, body SetAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSetAppDomainRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CheckDomain(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCheckDomainRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectDomainWithBody(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectDomainRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RedirectDomain(ctx context.Context, id string, body RedirectDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRedirectDomainRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DisableSsl(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDisableSslRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteFtp(ctx context.Context, fname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteFtpRequest(c.Server, fname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApps(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateAppWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateApp(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateAppRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UpdateEnvs(ctx context.Context, body UpdateEnvsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUpdateEnvsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DefaultSubdomain(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDefaultSubdomainRequest(c.Server, id, status)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetDisks(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetDisksRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DownloadBackup(ctx context.Context, id string, dname string, bname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDownloadBackupRequest(c.Server, id, dname, bname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteDisk(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteDiskRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetBackups(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetBackupsRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateBackup(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateBackupRequest(c.Server, id, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) IpStatic(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewIpStaticRequest(c.Server, id, status)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReadOnly(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReadOnlyRequest(c.Server, id, status)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ZeroDowntime(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewZeroDowntimeRequest(c.Server, id, status)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAppByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAppByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppByName(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppByNameRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) RestartApp(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewRestartAppRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TurnAppWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTurnAppRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) TurnApp(ctx context.Context, name string, body TurnAppJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewTurnAppRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppApplets(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppAppletsRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDiskWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDiskRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateDisk(ctx context.Context, name string, body CreateDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateDiskRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetFtps(ctx context.Context, name string, dname string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetFtpsRequest(c.Server, name, dname)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFtpWithBody(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFtpRequestWithBody(c.Server, name, dname, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CreateFtp(ctx context.Context, name string, dname string, body CreateFtpJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCreateFtpRequest(c.Server, name, dname, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDiskWithBody(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDiskRequestWithBody(c.Server, name, dname, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ResizeDisk(ctx context.Context, name string, dname string, body ResizeDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewResizeDiskRequest(c.Server, name, dname, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppEvents(ctx context.Context, name string, params *GetAppEventsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppEventsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppLogs(ctx context.Context, name string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppLogsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppCpuReports(ctx context.Context, name string, params *GetAppCpuReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppCpuReportsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppMemoryReports(ctx context.Context, name string, params *GetAppMemoryReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppMemoryReportsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppNetworkReceiveReports(ctx context.Context, name string, params *GetAppNetworkReceiveReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppNetworkReceiveReportsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetNetworkTransmitReports(ctx context.Context, name string, params *GetNetworkTransmitReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetNetworkTransmitReportsRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppSummaryReports(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppSummaryReportsRequest(c.Server, name)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAppReleases(ctx context.Context, name string, params *GetAppReleasesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAppReleasesRequest(c.Server, name, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePlanWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePlanRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ChangePlan(ctx context.Context, name string, body ChangePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewChangePlanRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleasesDeployWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleasesDeployRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ReleasesDeploy(ctx context.Context, name string, body ReleasesDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewReleasesDeployRequest(c.Server, name, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) SourcesDeployWithBody(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewSourcesDeployRequestWithBody(c.Server, name, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAppDomainsRequest generates requests for GetAppDomains
func NewGetAppDomainsRequest(server string, params *GetAppDomainsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "project", runtime.ParamLocationQuery, params.Project); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppDomainRequest calls the generic CreateAppDomain builder with application/json body
func NewCreateAppDomainRequest(server string, body CreateAppDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppDomainRequestWithBody generates requests for CreateAppDomain with any type of body
func NewCreateAppDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewEnableSslRequest calls the generic EnableSsl builder with application/json body
func NewEnableSslRequest(server string, body EnableSslJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEnableSslRequestWithBody(server, "application/json", bodyReader)
}

// NewEnableSslRequestWithBody generates requests for EnableSsl with any type of body
func NewEnableSslRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/provision-ssl-certs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSetAppDomainRequest calls the generic SetAppDomain builder with application/json body
func NewSetAppDomainRequest(server string, body SetAppDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewSetAppDomainRequestWithBody(server, "application/json", bodyReader)
}

// NewSetAppDomainRequestWithBody generates requests for SetAppDomain with any type of body
func NewSetAppDomainRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/set-project")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteDomainRequest generates requests for DeleteDomain
func NewDeleteDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCheckDomainRequest generates requests for CheckDomain
func NewCheckDomainRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/check", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRedirectDomainRequest calls the generic RedirectDomain builder with application/json body
func NewRedirectDomainRequest(server string, id string, body RedirectDomainJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewRedirectDomainRequestWithBody(server, id, "application/json", bodyReader)
}

// NewRedirectDomainRequestWithBody generates requests for RedirectDomain with any type of body
func NewRedirectDomainRequestWithBody(server string, id string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/set-redirect", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDisableSslRequest generates requests for DisableSsl
func NewDisableSslRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/domains/%s/ssl/disable", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteFtpRequest generates requests for DeleteFtp
func NewDeleteFtpRequest(server string, fname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "fname", runtime.ParamLocationPath, fname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/ftp/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppsRequest generates requests for GetApps
func NewGetAppsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateAppRequest calls the generic CreateApp builder with application/json body
func NewCreateAppRequest(server string, body CreateAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateAppRequestWithBody(server, "application/json", bodyReader)
}

// NewCreateAppRequestWithBody generates requests for CreateApp with any type of body
func NewCreateAppRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewUpdateEnvsRequest calls the generic UpdateEnvs builder with application/json body
func NewUpdateEnvsRequest(server string, body UpdateEnvsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUpdateEnvsRequestWithBody(server, "application/json", bodyReader)
}

// NewUpdateEnvsRequestWithBody generates requests for UpdateEnvs with any type of body
func NewUpdateEnvsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/update-envs")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDefaultSubdomainRequest generates requests for DefaultSubdomain
func NewDefaultSubdomainRequest(server string, id string, status string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "status", runtime.ParamLocationPath, status)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/default-subdomain/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetDisksRequest generates requests for GetDisks
func NewGetDisksRequest(server string, id string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDownloadBackupRequest generates requests for DownloadBackup
func NewDownloadBackupRequest(server string, id string, dname string, bname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dname", runtime.ParamLocationPath, dname)
	if err != nil {
		return nil, err
	}

	var pathParam2 string

	pathParam2, err = runtime.StyleParamWithLocation("simple", false, "bname", runtime.ParamLocationPath, bname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/backups/%s/download", pathParam0, pathParam1, pathParam2)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteDiskRequest generates requests for DeleteDisk
func NewDeleteDiskRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetBackupsRequest generates requests for GetBackups
func NewGetBackupsRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/backups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateBackupRequest generates requests for CreateBackup
func NewCreateBackupRequest(server string, id string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/backups", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewIpStaticRequest generates requests for IpStatic
func NewIpStaticRequest(server string, id string, status string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "status", runtime.ParamLocationPath, status)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/fixed-ip/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewReadOnlyRequest generates requests for ReadOnly
func NewReadOnlyRequest(server string, id string, status string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "status", runtime.ParamLocationPath, status)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/read-only/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewZeroDowntimeRequest generates requests for ZeroDowntime
func NewZeroDowntimeRequest(server string, id string, status string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "status", runtime.ParamLocationPath, status)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/zero-downtime/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteAppByNameRequest generates requests for DeleteAppByName
func NewDeleteAppByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppByNameRequest generates requests for GetAppByName
func NewGetAppByNameRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewRestartAppRequest generates requests for RestartApp
func NewRestartAppRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/actions/restart", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewTurnAppRequest calls the generic TurnApp builder with application/json body
func NewTurnAppRequest(server string, name string, body TurnAppJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewTurnAppRequestWithBody(server, name, "application/json", bodyReader)
}

// NewTurnAppRequestWithBody generates requests for TurnApp with any type of body
func NewTurnAppRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/actions/scale", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppAppletsRequest generates requests for GetAppApplets
func NewGetAppAppletsRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/applets", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateDiskRequest calls the generic CreateDisk builder with application/json body
func NewCreateDiskRequest(server string, name string, body CreateDiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateDiskRequestWithBody(server, name, "application/json", bodyReader)
}

// NewCreateDiskRequestWithBody generates requests for CreateDisk with any type of body
func NewCreateDiskRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetFtpsRequest generates requests for GetFtps
func NewGetFtpsRequest(server string, name string, dname string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dname", runtime.ParamLocationPath, dname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/ftp", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCreateFtpRequest calls the generic CreateFtp builder with application/json body
func NewCreateFtpRequest(server string, name string, dname string, body CreateFtpJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCreateFtpRequestWithBody(server, name, dname, "application/json", bodyReader)
}

// NewCreateFtpRequestWithBody generates requests for CreateFtp with any type of body
func NewCreateFtpRequestWithBody(server string, name string, dname string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dname", runtime.ParamLocationPath, dname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/ftp", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewResizeDiskRequest calls the generic ResizeDisk builder with application/json body
func NewResizeDiskRequest(server string, name string, dname string, body ResizeDiskJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewResizeDiskRequestWithBody(server, name, dname, "application/json", bodyReader)
}

// NewResizeDiskRequestWithBody generates requests for ResizeDisk with any type of body
func NewResizeDiskRequestWithBody(server string, name string, dname string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "dname", runtime.ParamLocationPath, dname)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/disks/%s/resize", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetAppEventsRequest generates requests for GetAppEvents
func NewGetAppEventsRequest(server string, name string, params *GetAppEventsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/events", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Search != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "search", runtime.ParamLocationQuery, *params.Search); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Start != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "start", runtime.ParamLocationQuery, *params.Start); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.End != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "end", runtime.ParamLocationQuery, *params.End); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppLogsRequest generates requests for GetAppLogs
func NewGetAppLogsRequest(server string, name string, params *GetAppLogsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/logs", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppCpuReportsRequest generates requests for GetAppCpuReports
func NewGetAppCpuReportsRequest(server string, name string, params *GetAppCpuReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/metrics/cpu", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppMemoryReportsRequest generates requests for GetAppMemoryReports
func NewGetAppMemoryReportsRequest(server string, name string, params *GetAppMemoryReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/metrics/memory", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppNetworkReceiveReportsRequest generates requests for GetAppNetworkReceiveReports
func NewGetAppNetworkReceiveReportsRequest(server string, name string, params *GetAppNetworkReceiveReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/metrics/network-receive", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetNetworkTransmitReportsRequest generates requests for GetNetworkTransmitReports
func NewGetNetworkTransmitReportsRequest(server string, name string, params *GetNetworkTransmitReportsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/metrics/network-transmit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "since", runtime.ParamLocationQuery, params.Since); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppSummaryReportsRequest generates requests for GetAppSummaryReports
func NewGetAppSummaryReportsRequest(server string, name string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/metrics/summary", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAppReleasesRequest generates requests for GetAppReleases
func NewGetAppReleasesRequest(server string, name string, params *GetAppReleasesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/releases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "page", runtime.ParamLocationQuery, params.Page); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "count", runtime.ParamLocationQuery, params.Count); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewChangePlanRequest calls the generic ChangePlan builder with application/json body
func NewChangePlanRequest(server string, name string, body ChangePlanJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewChangePlanRequestWithBody(server, name, "application/json", bodyReader)
}

// NewChangePlanRequestWithBody generates requests for ChangePlan with any type of body
func NewChangePlanRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v1/projects/%s/resize", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewReleasesDeployRequest calls the generic ReleasesDeploy builder with application/json body
func NewReleasesDeployRequest(server string, name string, body ReleasesDeployJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewReleasesDeployRequestWithBody(server, name, "application/json", bodyReader)
}

// NewReleasesDeployRequestWithBody generates requests for ReleasesDeploy with any type of body
func NewReleasesDeployRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/releases", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewSourcesDeployRequestWithBody generates requests for SourcesDeploy with any type of body
func NewSourcesDeployRequestWithBody(server string, name string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "name", runtime.ParamLocationPath, name)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/v2/projects/%s/sources", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAppDomainsWithResponse request
	GetAppDomainsWithResponse(ctx context.Context, params *GetAppDomainsParams, reqEditors ...RequestEditorFn) (*GetAppDomainsResp, error)

	// CreateAppDomainWithBodyWithResponse request with any body
	CreateAppDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppDomainResp, error)

	CreateAppDomainWithResponse(ctx context.Context, body CreateAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppDomainResp, error)

	// EnableSslWithBodyWithResponse request with any body
	EnableSslWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableSslResp, error)

	EnableSslWithResponse(ctx context.Context, body EnableSslJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableSslResp, error)

	// SetAppDomainWithBodyWithResponse request with any body
	SetAppDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppDomainResp, error)

	SetAppDomainWithResponse(ctx context.Context, body SetAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppDomainResp, error)

	// DeleteDomainWithResponse request
	DeleteDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDomainResp, error)

	// CheckDomainWithResponse request
	CheckDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CheckDomainResp, error)

	// RedirectDomainWithBodyWithResponse request with any body
	RedirectDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectDomainResp, error)

	RedirectDomainWithResponse(ctx context.Context, id string, body RedirectDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectDomainResp, error)

	// DisableSslWithResponse request
	DisableSslWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DisableSslResp, error)

	// DeleteFtpWithResponse request
	DeleteFtpWithResponse(ctx context.Context, fname string, reqEditors ...RequestEditorFn) (*DeleteFtpResp, error)

	// GetAppsWithResponse request
	GetAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAppsResp, error)

	// CreateAppWithBodyWithResponse request with any body
	CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResp, error)

	CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResp, error)

	// UpdateEnvsWithBodyWithResponse request with any body
	UpdateEnvsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsResp, error)

	UpdateEnvsWithResponse(ctx context.Context, body UpdateEnvsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsResp, error)

	// DefaultSubdomainWithResponse request
	DefaultSubdomainWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*DefaultSubdomainResp, error)

	// GetDisksWithResponse request
	GetDisksWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDisksResp, error)

	// DownloadBackupWithResponse request
	DownloadBackupWithResponse(ctx context.Context, id string, dname string, bname string, reqEditors ...RequestEditorFn) (*DownloadBackupResp, error)

	// DeleteDiskWithResponse request
	DeleteDiskWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*DeleteDiskResp, error)

	// GetBackupsWithResponse request
	GetBackupsWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetBackupsResp, error)

	// CreateBackupWithResponse request
	CreateBackupWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*CreateBackupResp, error)

	// IpStaticWithResponse request
	IpStaticWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*IpStaticResp, error)

	// ReadOnlyWithResponse request
	ReadOnlyWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*ReadOnlyResp, error)

	// ZeroDowntimeWithResponse request
	ZeroDowntimeWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*ZeroDowntimeResp, error)

	// DeleteAppByNameWithResponse request
	DeleteAppByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteAppByNameResp, error)

	// GetAppByNameWithResponse request
	GetAppByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppByNameResp, error)

	// RestartAppWithResponse request
	RestartAppWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RestartAppResp, error)

	// TurnAppWithBodyWithResponse request with any body
	TurnAppWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TurnAppResp, error)

	TurnAppWithResponse(ctx context.Context, name string, body TurnAppJSONRequestBody, reqEditors ...RequestEditorFn) (*TurnAppResp, error)

	// GetAppAppletsWithResponse request
	GetAppAppletsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppAppletsResp, error)

	// CreateDiskWithBodyWithResponse request with any body
	CreateDiskWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDiskResp, error)

	CreateDiskWithResponse(ctx context.Context, name string, body CreateDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDiskResp, error)

	// GetFtpsWithResponse request
	GetFtpsWithResponse(ctx context.Context, name string, dname string, reqEditors ...RequestEditorFn) (*GetFtpsResp, error)

	// CreateFtpWithBodyWithResponse request with any body
	CreateFtpWithBodyWithResponse(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFtpResp, error)

	CreateFtpWithResponse(ctx context.Context, name string, dname string, body CreateFtpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFtpResp, error)

	// ResizeDiskWithBodyWithResponse request with any body
	ResizeDiskWithBodyWithResponse(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDiskResp, error)

	ResizeDiskWithResponse(ctx context.Context, name string, dname string, body ResizeDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDiskResp, error)

	// GetAppEventsWithResponse request
	GetAppEventsWithResponse(ctx context.Context, name string, params *GetAppEventsParams, reqEditors ...RequestEditorFn) (*GetAppEventsResp, error)

	// GetAppLogsWithResponse request
	GetAppLogsWithResponse(ctx context.Context, name string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResp, error)

	// GetAppCpuReportsWithResponse request
	GetAppCpuReportsWithResponse(ctx context.Context, name string, params *GetAppCpuReportsParams, reqEditors ...RequestEditorFn) (*GetAppCpuReportsResp, error)

	// GetAppMemoryReportsWithResponse request
	GetAppMemoryReportsWithResponse(ctx context.Context, name string, params *GetAppMemoryReportsParams, reqEditors ...RequestEditorFn) (*GetAppMemoryReportsResp, error)

	// GetAppNetworkReceiveReportsWithResponse request
	GetAppNetworkReceiveReportsWithResponse(ctx context.Context, name string, params *GetAppNetworkReceiveReportsParams, reqEditors ...RequestEditorFn) (*GetAppNetworkReceiveReportsResp, error)

	// GetNetworkTransmitReportsWithResponse request
	GetNetworkTransmitReportsWithResponse(ctx context.Context, name string, params *GetNetworkTransmitReportsParams, reqEditors ...RequestEditorFn) (*GetNetworkTransmitReportsResp, error)

	// GetAppSummaryReportsWithResponse request
	GetAppSummaryReportsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppSummaryReportsResp, error)

	// GetAppReleasesWithResponse request
	GetAppReleasesWithResponse(ctx context.Context, name string, params *GetAppReleasesParams, reqEditors ...RequestEditorFn) (*GetAppReleasesResp, error)

	// ChangePlanWithBodyWithResponse request with any body
	ChangePlanWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePlanResp, error)

	ChangePlanWithResponse(ctx context.Context, name string, body ChangePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePlanResp, error)

	// ReleasesDeployWithBodyWithResponse request with any body
	ReleasesDeployWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleasesDeployResp, error)

	ReleasesDeployWithResponse(ctx context.Context, name string, body ReleasesDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleasesDeployResp, error)

	// SourcesDeployWithBodyWithResponse request with any body
	SourcesDeployWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SourcesDeployResp, error)
}

type GetAppDomainsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Domains
}

// Status returns HTTPResponse.Status
func (r GetAppDomainsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppDomainsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *struct {
		Domain *struct {
			UnderscoreId *string `json:"_id,omitempty"`
		} `json:"domain,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateAppDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EnableSslResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Code *string `json:"code,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r EnableSslResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EnableSslResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SetAppDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r SetAppDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SetAppDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CheckDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckDomain
}

// Status returns HTTPResponse.Status
func (r CheckDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CheckDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RedirectDomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RedirectDomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RedirectDomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DisableSslResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DisableSslResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DisableSslResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteFtpResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteFtpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteFtpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Projects
}

// Status returns HTTPResponse.Status
func (r GetAppsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UpdateEnvsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Message *string `json:"message,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r UpdateEnvsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UpdateEnvsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DefaultSubdomainResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DefaultSubdomainResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DefaultSubdomainResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetDisksResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDisks
}

// Status returns HTTPResponse.Status
func (r GetDisksResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDisksResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DownloadBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Link *string `json:"link,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r DownloadBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DownloadBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteDiskResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteDiskResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteDiskResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetBackupsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *GetDiskBackup
}

// Status returns HTTPResponse.Status
func (r GetBackupsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetBackupsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateBackupResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateBackupResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateBackupResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type IpStaticResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		IP *string `json:"IP,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r IpStaticResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r IpStaticResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReadOnlyResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ReadOnlyResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReadOnlyResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ZeroDowntimeResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ZeroDowntimeResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ZeroDowntimeResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAppByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteAppByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAppByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppByNameResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ProjectAllDetails
}

// Status returns HTTPResponse.Status
func (r GetAppByNameResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppByNameResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type RestartAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r RestartAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r RestartAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type TurnAppResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r TurnAppResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r TurnAppResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppAppletsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Applets
}

// Status returns HTTPResponse.Status
func (r GetAppAppletsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppAppletsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateDiskResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r CreateDiskResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateDiskResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetFtpsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Accesses *[]struct {
			UnderscoreUnderscoreV *int       `json:"__v,omitempty"`
			UnderscoreId          *string    `json:"_id,omitempty"`
			CreatedAt             *time.Time `json:"createdAt,omitempty"`
			Disk                  *string    `json:"disk,omitempty"`
			Password              *string    `json:"password,omitempty"`
			ReadOnly              *bool      `json:"readOnly,omitempty"`
			Username              *string    `json:"username,omitempty"`
		} `json:"accesses,omitempty"`
		Host *string `json:"host,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetFtpsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetFtpsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CreateFtpResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Host     *string `json:"host,omitempty"`
		Password *string `json:"password,omitempty"`
		Username *string `json:"username,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r CreateFtpResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CreateFtpResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ResizeDiskResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ResizeDiskResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ResizeDiskResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppEventsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data []struct {
			MetaData *map[string]interface{} `json:"metaData,omitempty"`
			Values   *[][]string             `json:"values,omitempty"`
		} `json:"data"`
	}
}

// Status returns HTTPResponse.Status
func (r GetAppEventsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppEventsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppLogsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Logs
}

// Status returns HTTPResponse.Status
func (r GetAppLogsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppLogsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppCpuReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reports
}

// Status returns HTTPResponse.Status
func (r GetAppCpuReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppCpuReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppMemoryReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reports
}

// Status returns HTTPResponse.Status
func (r GetAppMemoryReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppMemoryReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppNetworkReceiveReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reports
}

// Status returns HTTPResponse.Status
func (r GetAppNetworkReceiveReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppNetworkReceiveReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetNetworkTransmitReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Reports
}

// Status returns HTTPResponse.Status
func (r GetNetworkTransmitReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetNetworkTransmitReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppSummaryReportsResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		CpuUsage *[]struct {
			Applet *string                                         `json:"applet,omitempty"`
			Value  *[]GetAppSummaryReports_200_CpuUsage_Value_Item `json:"value,omitempty"`
		} `json:"cpuUsage,omitempty"`
		DisksUsage *[]struct {
			Name       *string `json:"name,omitempty"`
			ReportedAt *string `json:"reportedAt,omitempty"`
			Size       *string `json:"size,omitempty"`
			Usage      *string `json:"usage,omitempty"`
		} `json:"disksUsage,omitempty"`
		MemoryUsage *[]struct {
			Applet *string                                            `json:"applet,omitempty"`
			Value  *[]GetAppSummaryReports_200_MemoryUsage_Value_Item `json:"value,omitempty"`
		} `json:"memoryUsage,omitempty"`
	}
}
type GetAppSummaryReports200CpuUsageValue0 = float32
type GetAppSummaryReports200CpuUsageValue1 = string
type GetAppSummaryReports_200_CpuUsage_Value_Item struct {
	union json.RawMessage
}
type GetAppSummaryReports200MemoryUsageValue0 = float32
type GetAppSummaryReports200MemoryUsageValue1 = string
type GetAppSummaryReports_200_MemoryUsage_Value_Item struct {
	union json.RawMessage
}

// Status returns HTTPResponse.Status
func (r GetAppSummaryReportsResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppSummaryReportsResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAppReleasesResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Releases
}

// Status returns HTTPResponse.Status
func (r GetAppReleasesResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAppReleasesResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ChangePlanResp struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r ChangePlanResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ChangePlanResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ReleasesDeployResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		ReleaseID *string `json:"releaseID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r ReleasesDeployResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ReleasesDeployResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type SourcesDeployResp struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		SourceID *string `json:"sourceID,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r SourcesDeployResp) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r SourcesDeployResp) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAppDomainsWithResponse request returning *GetAppDomainsResp
func (c *ClientWithResponses) GetAppDomainsWithResponse(ctx context.Context, params *GetAppDomainsParams, reqEditors ...RequestEditorFn) (*GetAppDomainsResp, error) {
	rsp, err := c.GetAppDomains(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppDomainsResp(rsp)
}

// CreateAppDomainWithBodyWithResponse request with arbitrary body returning *CreateAppDomainResp
func (c *ClientWithResponses) CreateAppDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppDomainResp, error) {
	rsp, err := c.CreateAppDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppDomainResp(rsp)
}

func (c *ClientWithResponses) CreateAppDomainWithResponse(ctx context.Context, body CreateAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppDomainResp, error) {
	rsp, err := c.CreateAppDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppDomainResp(rsp)
}

// EnableSslWithBodyWithResponse request with arbitrary body returning *EnableSslResp
func (c *ClientWithResponses) EnableSslWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EnableSslResp, error) {
	rsp, err := c.EnableSslWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableSslResp(rsp)
}

func (c *ClientWithResponses) EnableSslWithResponse(ctx context.Context, body EnableSslJSONRequestBody, reqEditors ...RequestEditorFn) (*EnableSslResp, error) {
	rsp, err := c.EnableSsl(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEnableSslResp(rsp)
}

// SetAppDomainWithBodyWithResponse request with arbitrary body returning *SetAppDomainResp
func (c *ClientWithResponses) SetAppDomainWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SetAppDomainResp, error) {
	rsp, err := c.SetAppDomainWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppDomainResp(rsp)
}

func (c *ClientWithResponses) SetAppDomainWithResponse(ctx context.Context, body SetAppDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*SetAppDomainResp, error) {
	rsp, err := c.SetAppDomain(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSetAppDomainResp(rsp)
}

// DeleteDomainWithResponse request returning *DeleteDomainResp
func (c *ClientWithResponses) DeleteDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DeleteDomainResp, error) {
	rsp, err := c.DeleteDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDomainResp(rsp)
}

// CheckDomainWithResponse request returning *CheckDomainResp
func (c *ClientWithResponses) CheckDomainWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*CheckDomainResp, error) {
	rsp, err := c.CheckDomain(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCheckDomainResp(rsp)
}

// RedirectDomainWithBodyWithResponse request with arbitrary body returning *RedirectDomainResp
func (c *ClientWithResponses) RedirectDomainWithBodyWithResponse(ctx context.Context, id string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*RedirectDomainResp, error) {
	rsp, err := c.RedirectDomainWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectDomainResp(rsp)
}

func (c *ClientWithResponses) RedirectDomainWithResponse(ctx context.Context, id string, body RedirectDomainJSONRequestBody, reqEditors ...RequestEditorFn) (*RedirectDomainResp, error) {
	rsp, err := c.RedirectDomain(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRedirectDomainResp(rsp)
}

// DisableSslWithResponse request returning *DisableSslResp
func (c *ClientWithResponses) DisableSslWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*DisableSslResp, error) {
	rsp, err := c.DisableSsl(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDisableSslResp(rsp)
}

// DeleteFtpWithResponse request returning *DeleteFtpResp
func (c *ClientWithResponses) DeleteFtpWithResponse(ctx context.Context, fname string, reqEditors ...RequestEditorFn) (*DeleteFtpResp, error) {
	rsp, err := c.DeleteFtp(ctx, fname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteFtpResp(rsp)
}

// GetAppsWithResponse request returning *GetAppsResp
func (c *ClientWithResponses) GetAppsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAppsResp, error) {
	rsp, err := c.GetApps(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppsResp(rsp)
}

// CreateAppWithBodyWithResponse request with arbitrary body returning *CreateAppResp
func (c *ClientWithResponses) CreateAppWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateAppResp, error) {
	rsp, err := c.CreateAppWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResp(rsp)
}

func (c *ClientWithResponses) CreateAppWithResponse(ctx context.Context, body CreateAppJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateAppResp, error) {
	rsp, err := c.CreateApp(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateAppResp(rsp)
}

// UpdateEnvsWithBodyWithResponse request with arbitrary body returning *UpdateEnvsResp
func (c *ClientWithResponses) UpdateEnvsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UpdateEnvsResp, error) {
	rsp, err := c.UpdateEnvsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsResp(rsp)
}

func (c *ClientWithResponses) UpdateEnvsWithResponse(ctx context.Context, body UpdateEnvsJSONRequestBody, reqEditors ...RequestEditorFn) (*UpdateEnvsResp, error) {
	rsp, err := c.UpdateEnvs(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUpdateEnvsResp(rsp)
}

// DefaultSubdomainWithResponse request returning *DefaultSubdomainResp
func (c *ClientWithResponses) DefaultSubdomainWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*DefaultSubdomainResp, error) {
	rsp, err := c.DefaultSubdomain(ctx, id, status, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDefaultSubdomainResp(rsp)
}

// GetDisksWithResponse request returning *GetDisksResp
func (c *ClientWithResponses) GetDisksWithResponse(ctx context.Context, id string, reqEditors ...RequestEditorFn) (*GetDisksResp, error) {
	rsp, err := c.GetDisks(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetDisksResp(rsp)
}

// DownloadBackupWithResponse request returning *DownloadBackupResp
func (c *ClientWithResponses) DownloadBackupWithResponse(ctx context.Context, id string, dname string, bname string, reqEditors ...RequestEditorFn) (*DownloadBackupResp, error) {
	rsp, err := c.DownloadBackup(ctx, id, dname, bname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDownloadBackupResp(rsp)
}

// DeleteDiskWithResponse request returning *DeleteDiskResp
func (c *ClientWithResponses) DeleteDiskWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*DeleteDiskResp, error) {
	rsp, err := c.DeleteDisk(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteDiskResp(rsp)
}

// GetBackupsWithResponse request returning *GetBackupsResp
func (c *ClientWithResponses) GetBackupsWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*GetBackupsResp, error) {
	rsp, err := c.GetBackups(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetBackupsResp(rsp)
}

// CreateBackupWithResponse request returning *CreateBackupResp
func (c *ClientWithResponses) CreateBackupWithResponse(ctx context.Context, id string, name string, reqEditors ...RequestEditorFn) (*CreateBackupResp, error) {
	rsp, err := c.CreateBackup(ctx, id, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateBackupResp(rsp)
}

// IpStaticWithResponse request returning *IpStaticResp
func (c *ClientWithResponses) IpStaticWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*IpStaticResp, error) {
	rsp, err := c.IpStatic(ctx, id, status, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseIpStaticResp(rsp)
}

// ReadOnlyWithResponse request returning *ReadOnlyResp
func (c *ClientWithResponses) ReadOnlyWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*ReadOnlyResp, error) {
	rsp, err := c.ReadOnly(ctx, id, status, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReadOnlyResp(rsp)
}

// ZeroDowntimeWithResponse request returning *ZeroDowntimeResp
func (c *ClientWithResponses) ZeroDowntimeWithResponse(ctx context.Context, id string, status string, reqEditors ...RequestEditorFn) (*ZeroDowntimeResp, error) {
	rsp, err := c.ZeroDowntime(ctx, id, status, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseZeroDowntimeResp(rsp)
}

// DeleteAppByNameWithResponse request returning *DeleteAppByNameResp
func (c *ClientWithResponses) DeleteAppByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*DeleteAppByNameResp, error) {
	rsp, err := c.DeleteAppByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAppByNameResp(rsp)
}

// GetAppByNameWithResponse request returning *GetAppByNameResp
func (c *ClientWithResponses) GetAppByNameWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppByNameResp, error) {
	rsp, err := c.GetAppByName(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppByNameResp(rsp)
}

// RestartAppWithResponse request returning *RestartAppResp
func (c *ClientWithResponses) RestartAppWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*RestartAppResp, error) {
	rsp, err := c.RestartApp(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseRestartAppResp(rsp)
}

// TurnAppWithBodyWithResponse request with arbitrary body returning *TurnAppResp
func (c *ClientWithResponses) TurnAppWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*TurnAppResp, error) {
	rsp, err := c.TurnAppWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTurnAppResp(rsp)
}

func (c *ClientWithResponses) TurnAppWithResponse(ctx context.Context, name string, body TurnAppJSONRequestBody, reqEditors ...RequestEditorFn) (*TurnAppResp, error) {
	rsp, err := c.TurnApp(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseTurnAppResp(rsp)
}

// GetAppAppletsWithResponse request returning *GetAppAppletsResp
func (c *ClientWithResponses) GetAppAppletsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppAppletsResp, error) {
	rsp, err := c.GetAppApplets(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppAppletsResp(rsp)
}

// CreateDiskWithBodyWithResponse request with arbitrary body returning *CreateDiskResp
func (c *ClientWithResponses) CreateDiskWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateDiskResp, error) {
	rsp, err := c.CreateDiskWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDiskResp(rsp)
}

func (c *ClientWithResponses) CreateDiskWithResponse(ctx context.Context, name string, body CreateDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateDiskResp, error) {
	rsp, err := c.CreateDisk(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateDiskResp(rsp)
}

// GetFtpsWithResponse request returning *GetFtpsResp
func (c *ClientWithResponses) GetFtpsWithResponse(ctx context.Context, name string, dname string, reqEditors ...RequestEditorFn) (*GetFtpsResp, error) {
	rsp, err := c.GetFtps(ctx, name, dname, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetFtpsResp(rsp)
}

// CreateFtpWithBodyWithResponse request with arbitrary body returning *CreateFtpResp
func (c *ClientWithResponses) CreateFtpWithBodyWithResponse(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CreateFtpResp, error) {
	rsp, err := c.CreateFtpWithBody(ctx, name, dname, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFtpResp(rsp)
}

func (c *ClientWithResponses) CreateFtpWithResponse(ctx context.Context, name string, dname string, body CreateFtpJSONRequestBody, reqEditors ...RequestEditorFn) (*CreateFtpResp, error) {
	rsp, err := c.CreateFtp(ctx, name, dname, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCreateFtpResp(rsp)
}

// ResizeDiskWithBodyWithResponse request with arbitrary body returning *ResizeDiskResp
func (c *ClientWithResponses) ResizeDiskWithBodyWithResponse(ctx context.Context, name string, dname string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ResizeDiskResp, error) {
	rsp, err := c.ResizeDiskWithBody(ctx, name, dname, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDiskResp(rsp)
}

func (c *ClientWithResponses) ResizeDiskWithResponse(ctx context.Context, name string, dname string, body ResizeDiskJSONRequestBody, reqEditors ...RequestEditorFn) (*ResizeDiskResp, error) {
	rsp, err := c.ResizeDisk(ctx, name, dname, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseResizeDiskResp(rsp)
}

// GetAppEventsWithResponse request returning *GetAppEventsResp
func (c *ClientWithResponses) GetAppEventsWithResponse(ctx context.Context, name string, params *GetAppEventsParams, reqEditors ...RequestEditorFn) (*GetAppEventsResp, error) {
	rsp, err := c.GetAppEvents(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppEventsResp(rsp)
}

// GetAppLogsWithResponse request returning *GetAppLogsResp
func (c *ClientWithResponses) GetAppLogsWithResponse(ctx context.Context, name string, params *GetAppLogsParams, reqEditors ...RequestEditorFn) (*GetAppLogsResp, error) {
	rsp, err := c.GetAppLogs(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppLogsResp(rsp)
}

// GetAppCpuReportsWithResponse request returning *GetAppCpuReportsResp
func (c *ClientWithResponses) GetAppCpuReportsWithResponse(ctx context.Context, name string, params *GetAppCpuReportsParams, reqEditors ...RequestEditorFn) (*GetAppCpuReportsResp, error) {
	rsp, err := c.GetAppCpuReports(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppCpuReportsResp(rsp)
}

// GetAppMemoryReportsWithResponse request returning *GetAppMemoryReportsResp
func (c *ClientWithResponses) GetAppMemoryReportsWithResponse(ctx context.Context, name string, params *GetAppMemoryReportsParams, reqEditors ...RequestEditorFn) (*GetAppMemoryReportsResp, error) {
	rsp, err := c.GetAppMemoryReports(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppMemoryReportsResp(rsp)
}

// GetAppNetworkReceiveReportsWithResponse request returning *GetAppNetworkReceiveReportsResp
func (c *ClientWithResponses) GetAppNetworkReceiveReportsWithResponse(ctx context.Context, name string, params *GetAppNetworkReceiveReportsParams, reqEditors ...RequestEditorFn) (*GetAppNetworkReceiveReportsResp, error) {
	rsp, err := c.GetAppNetworkReceiveReports(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppNetworkReceiveReportsResp(rsp)
}

// GetNetworkTransmitReportsWithResponse request returning *GetNetworkTransmitReportsResp
func (c *ClientWithResponses) GetNetworkTransmitReportsWithResponse(ctx context.Context, name string, params *GetNetworkTransmitReportsParams, reqEditors ...RequestEditorFn) (*GetNetworkTransmitReportsResp, error) {
	rsp, err := c.GetNetworkTransmitReports(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetNetworkTransmitReportsResp(rsp)
}

// GetAppSummaryReportsWithResponse request returning *GetAppSummaryReportsResp
func (c *ClientWithResponses) GetAppSummaryReportsWithResponse(ctx context.Context, name string, reqEditors ...RequestEditorFn) (*GetAppSummaryReportsResp, error) {
	rsp, err := c.GetAppSummaryReports(ctx, name, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppSummaryReportsResp(rsp)
}

// GetAppReleasesWithResponse request returning *GetAppReleasesResp
func (c *ClientWithResponses) GetAppReleasesWithResponse(ctx context.Context, name string, params *GetAppReleasesParams, reqEditors ...RequestEditorFn) (*GetAppReleasesResp, error) {
	rsp, err := c.GetAppReleases(ctx, name, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAppReleasesResp(rsp)
}

// ChangePlanWithBodyWithResponse request with arbitrary body returning *ChangePlanResp
func (c *ClientWithResponses) ChangePlanWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ChangePlanResp, error) {
	rsp, err := c.ChangePlanWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePlanResp(rsp)
}

func (c *ClientWithResponses) ChangePlanWithResponse(ctx context.Context, name string, body ChangePlanJSONRequestBody, reqEditors ...RequestEditorFn) (*ChangePlanResp, error) {
	rsp, err := c.ChangePlan(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseChangePlanResp(rsp)
}

// ReleasesDeployWithBodyWithResponse request with arbitrary body returning *ReleasesDeployResp
func (c *ClientWithResponses) ReleasesDeployWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ReleasesDeployResp, error) {
	rsp, err := c.ReleasesDeployWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleasesDeployResp(rsp)
}

func (c *ClientWithResponses) ReleasesDeployWithResponse(ctx context.Context, name string, body ReleasesDeployJSONRequestBody, reqEditors ...RequestEditorFn) (*ReleasesDeployResp, error) {
	rsp, err := c.ReleasesDeploy(ctx, name, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseReleasesDeployResp(rsp)
}

// SourcesDeployWithBodyWithResponse request with arbitrary body returning *SourcesDeployResp
func (c *ClientWithResponses) SourcesDeployWithBodyWithResponse(ctx context.Context, name string, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*SourcesDeployResp, error) {
	rsp, err := c.SourcesDeployWithBody(ctx, name, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseSourcesDeployResp(rsp)
}

// ParseGetAppDomainsResp parses an HTTP response from a GetAppDomainsWithResponse call
func ParseGetAppDomainsResp(rsp *http.Response) (*GetAppDomainsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppDomainsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Domains
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAppDomainResp parses an HTTP response from a CreateAppDomainWithResponse call
func ParseCreateAppDomainResp(rsp *http.Response) (*CreateAppDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest struct {
			Domain *struct {
				UnderscoreId *string `json:"_id,omitempty"`
			} `json:"domain,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	}

	return response, nil
}

// ParseEnableSslResp parses an HTTP response from a EnableSslWithResponse call
func ParseEnableSslResp(rsp *http.Response) (*EnableSslResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EnableSslResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Code *string `json:"code,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSetAppDomainResp parses an HTTP response from a SetAppDomainWithResponse call
func ParseSetAppDomainResp(rsp *http.Response) (*SetAppDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SetAppDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteDomainResp parses an HTTP response from a DeleteDomainWithResponse call
func ParseDeleteDomainResp(rsp *http.Response) (*DeleteDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseCheckDomainResp parses an HTTP response from a CheckDomainWithResponse call
func ParseCheckDomainResp(rsp *http.Response) (*CheckDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CheckDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckDomain
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRedirectDomainResp parses an HTTP response from a RedirectDomainWithResponse call
func ParseRedirectDomainResp(rsp *http.Response) (*RedirectDomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RedirectDomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDisableSslResp parses an HTTP response from a DisableSslWithResponse call
func ParseDisableSslResp(rsp *http.Response) (*DisableSslResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DisableSslResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteFtpResp parses an HTTP response from a DeleteFtpWithResponse call
func ParseDeleteFtpResp(rsp *http.Response) (*DeleteFtpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteFtpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppsResp parses an HTTP response from a GetAppsWithResponse call
func ParseGetAppsResp(rsp *http.Response) (*GetAppsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Projects
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateAppResp parses an HTTP response from a CreateAppWithResponse call
func ParseCreateAppResp(rsp *http.Response) (*CreateAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseUpdateEnvsResp parses an HTTP response from a UpdateEnvsWithResponse call
func ParseUpdateEnvsResp(rsp *http.Response) (*UpdateEnvsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UpdateEnvsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Message *string `json:"message,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDefaultSubdomainResp parses an HTTP response from a DefaultSubdomainWithResponse call
func ParseDefaultSubdomainResp(rsp *http.Response) (*DefaultSubdomainResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DefaultSubdomainResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetDisksResp parses an HTTP response from a GetDisksWithResponse call
func ParseGetDisksResp(rsp *http.Response) (*GetDisksResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetDisksResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDisks
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDownloadBackupResp parses an HTTP response from a DownloadBackupWithResponse call
func ParseDownloadBackupResp(rsp *http.Response) (*DownloadBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DownloadBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Link *string `json:"link,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteDiskResp parses an HTTP response from a DeleteDiskWithResponse call
func ParseDeleteDiskResp(rsp *http.Response) (*DeleteDiskResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteDiskResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetBackupsResp parses an HTTP response from a GetBackupsWithResponse call
func ParseGetBackupsResp(rsp *http.Response) (*GetBackupsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetBackupsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest GetDiskBackup
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateBackupResp parses an HTTP response from a CreateBackupWithResponse call
func ParseCreateBackupResp(rsp *http.Response) (*CreateBackupResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateBackupResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseIpStaticResp parses an HTTP response from a IpStaticWithResponse call
func ParseIpStaticResp(rsp *http.Response) (*IpStaticResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &IpStaticResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			IP *string `json:"IP,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseReadOnlyResp parses an HTTP response from a ReadOnlyWithResponse call
func ParseReadOnlyResp(rsp *http.Response) (*ReadOnlyResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReadOnlyResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseZeroDowntimeResp parses an HTTP response from a ZeroDowntimeWithResponse call
func ParseZeroDowntimeResp(rsp *http.Response) (*ZeroDowntimeResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ZeroDowntimeResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseDeleteAppByNameResp parses an HTTP response from a DeleteAppByNameWithResponse call
func ParseDeleteAppByNameResp(rsp *http.Response) (*DeleteAppByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAppByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppByNameResp parses an HTTP response from a GetAppByNameWithResponse call
func ParseGetAppByNameResp(rsp *http.Response) (*GetAppByNameResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppByNameResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ProjectAllDetails
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseRestartAppResp parses an HTTP response from a RestartAppWithResponse call
func ParseRestartAppResp(rsp *http.Response) (*RestartAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &RestartAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseTurnAppResp parses an HTTP response from a TurnAppWithResponse call
func ParseTurnAppResp(rsp *http.Response) (*TurnAppResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &TurnAppResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppAppletsResp parses an HTTP response from a GetAppAppletsWithResponse call
func ParseGetAppAppletsResp(rsp *http.Response) (*GetAppAppletsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppAppletsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Applets
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateDiskResp parses an HTTP response from a CreateDiskWithResponse call
func ParseCreateDiskResp(rsp *http.Response) (*CreateDiskResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateDiskResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetFtpsResp parses an HTTP response from a GetFtpsWithResponse call
func ParseGetFtpsResp(rsp *http.Response) (*GetFtpsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetFtpsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Accesses *[]struct {
				UnderscoreUnderscoreV *int       `json:"__v,omitempty"`
				UnderscoreId          *string    `json:"_id,omitempty"`
				CreatedAt             *time.Time `json:"createdAt,omitempty"`
				Disk                  *string    `json:"disk,omitempty"`
				Password              *string    `json:"password,omitempty"`
				ReadOnly              *bool      `json:"readOnly,omitempty"`
				Username              *string    `json:"username,omitempty"`
			} `json:"accesses,omitempty"`
			Host *string `json:"host,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCreateFtpResp parses an HTTP response from a CreateFtpWithResponse call
func ParseCreateFtpResp(rsp *http.Response) (*CreateFtpResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CreateFtpResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Host     *string `json:"host,omitempty"`
			Password *string `json:"password,omitempty"`
			Username *string `json:"username,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseResizeDiskResp parses an HTTP response from a ResizeDiskWithResponse call
func ParseResizeDiskResp(rsp *http.Response) (*ResizeDiskResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ResizeDiskResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetAppEventsResp parses an HTTP response from a GetAppEventsWithResponse call
func ParseGetAppEventsResp(rsp *http.Response) (*GetAppEventsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppEventsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data []struct {
				MetaData *map[string]interface{} `json:"metaData,omitempty"`
				Values   *[][]string             `json:"values,omitempty"`
			} `json:"data"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppLogsResp parses an HTTP response from a GetAppLogsWithResponse call
func ParseGetAppLogsResp(rsp *http.Response) (*GetAppLogsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppLogsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Logs
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppCpuReportsResp parses an HTTP response from a GetAppCpuReportsWithResponse call
func ParseGetAppCpuReportsResp(rsp *http.Response) (*GetAppCpuReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppCpuReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppMemoryReportsResp parses an HTTP response from a GetAppMemoryReportsWithResponse call
func ParseGetAppMemoryReportsResp(rsp *http.Response) (*GetAppMemoryReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppMemoryReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppNetworkReceiveReportsResp parses an HTTP response from a GetAppNetworkReceiveReportsWithResponse call
func ParseGetAppNetworkReceiveReportsResp(rsp *http.Response) (*GetAppNetworkReceiveReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppNetworkReceiveReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetNetworkTransmitReportsResp parses an HTTP response from a GetNetworkTransmitReportsWithResponse call
func ParseGetNetworkTransmitReportsResp(rsp *http.Response) (*GetNetworkTransmitReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetNetworkTransmitReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Reports
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppSummaryReportsResp parses an HTTP response from a GetAppSummaryReportsWithResponse call
func ParseGetAppSummaryReportsResp(rsp *http.Response) (*GetAppSummaryReportsResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppSummaryReportsResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			CpuUsage *[]struct {
				Applet *string                                         `json:"applet,omitempty"`
				Value  *[]GetAppSummaryReports_200_CpuUsage_Value_Item `json:"value,omitempty"`
			} `json:"cpuUsage,omitempty"`
			DisksUsage *[]struct {
				Name       *string `json:"name,omitempty"`
				ReportedAt *string `json:"reportedAt,omitempty"`
				Size       *string `json:"size,omitempty"`
				Usage      *string `json:"usage,omitempty"`
			} `json:"disksUsage,omitempty"`
			MemoryUsage *[]struct {
				Applet *string                                            `json:"applet,omitempty"`
				Value  *[]GetAppSummaryReports_200_MemoryUsage_Value_Item `json:"value,omitempty"`
			} `json:"memoryUsage,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetAppReleasesResp parses an HTTP response from a GetAppReleasesWithResponse call
func ParseGetAppReleasesResp(rsp *http.Response) (*GetAppReleasesResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAppReleasesResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Releases
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseChangePlanResp parses an HTTP response from a ChangePlanWithResponse call
func ParseChangePlanResp(rsp *http.Response) (*ChangePlanResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ChangePlanResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseReleasesDeployResp parses an HTTP response from a ReleasesDeployWithResponse call
func ParseReleasesDeployResp(rsp *http.Response) (*ReleasesDeployResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ReleasesDeployResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			ReleaseID *string `json:"releaseID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseSourcesDeployResp parses an HTTP response from a SourcesDeployWithResponse call
func ParseSourcesDeployResp(rsp *http.Response) (*SourcesDeployResp, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &SourcesDeployResp{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			SourceID *string `json:"sourceID,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+xde2/buJb/KoR2/9gF7Dhpe/cR4GI3TdpBdu/MBEkGi71NMaGlY5sTidSQVFK3yHe/",
	"4EOWZJES5TqpnfafIBYP37/z5OtLFLMsZxSoFNHxl0jEC8iw/vckz1MwX3POcuCSgP6FqwQiIXNQkET9",
	"TUDEnOSSMBodR9cLQCRBbIZM/mgUyWUO0XEkJCd0Hj2OIoozcOdUKd15OWChyF25TVpf/hSwAF8BOrFR",
	"QrPLluL8rLOA8zNVRFmVoxUSz90FSDzvzPq4+sKmf0AsVWFCYunpkE7qHhBJMhASZ7mnQWVyVymuVtkP",
	"mHO8dFOcLiC+O2MZJrSNrcTz/fQXnMElxIxr8LW68/vv97XvtMimwPV34qaPVdEzEmMJ4kpiWQg3GQcs",
	"IfkdS2cyEaKA5MSdWMK9lZBzpsei1UlfY20Gd7JriPOCLmOWwC++JnBICIdYtrpejVxJcs2cJQj/oJkP",
	"joQiT7pGsxDAnQn3wM1cEUZPWQJBo+CEnp7OMc7z9uAHSSckF1iiJSvQA6YSSYYMQpziDuQD43ftMt8z",
	"jkoMOPLlKaY+QaPSNmhKnmI5YzzzFqpTNyiYA05+penykjH5nqQglkJC5u7yrEpflTRlLAVM3bN1BnnK",
	"lmMrFB2KKGdcerrEuFTdWbKCqz5VNVYAF6zgsVekG2VmmgAJMsTCKUkt3LsHtt2SLgY24lH45GOXdl6T",
	"lO1W1QhUw6zEdXTs925F78/oFq7tctp0PeU2pLGjvFV6dzn9rO7PWxPeDq25zJvZnfLdN6BdMqGhAfzt",
	"9hbhAllbCbgsmzqNa2h8GsNf1jXrHmLR0R4RABM/Q7bmZysGzU8gxwkRd+Mpju8Kh2ox37uYFqxl2OpL",
	"ioX8mSVkRiAZZmUI8hkciv3ruuiSSOVnT9e8Fphh1qHG01q3CJUwN/Cz1oWzwMdWL0dRxgra6edoAkg8",
	"BpCnhY9B4/k3Nu+qWXVEWeDOijMQAs9hiOnVP+mj6MKIjpM0PQOJSerStz2G6waCrU+kq1GoTJCewhKY",
	"4SKVV8W0ciPaRa5T1WRKq+yVfTKKgN57ZJJKaeYeyApAY77MZYPDazXfwdJtFuO02HS2Z+QTJOcXXaK/",
	"QdIz8gtW8HR5wUnskbw1AmdRlRYhojS6fNOnUjOgMnDiqPUYHFqTJWutac7X+YXb1wz3wwJM+afU+uEG",
	"uo2jOGj7hpeDAH4PyRkRd1c59gEgVsIUtYh7wCBinHoKnAKhc8RoXwlBxkTHCIaZ9x0FfAbOztgDLQV6",
	"u6A6RRCow7xdK9H9gjxAbT+9SJdqJP2l9YkDm7UtFpxg/fYMuf+I3syCvPR68XHBOVB52RWhbdLUQqWi",
	"L9zhlIjLsjWnSip5YMokTt011V2eqldhRWzGbh0x5Tgl4OuDSesroG6Ie53qk75iZoQSsfCXU6X3FDQn",
	"8pzOmGNlopALxh3OU4ZJqkN4RZriqWIvyQvocPx7CF34nXJM40VQLTHLMiIHkK5GX4FWiU3tAIy1whj1",
	"F1JzCHppOWRMhpFKvOajeARJF9eTDM9XUWgHuMvkHkj0B/pamSsetYLs2i/1KoKedpgo4Mk9JnbonDK4",
	"SeQssqaSQpZxnmJJKSROMmg9at3F0NJvY9nq1iFqul3hE5p41jBEkcoOK8eubHm9qyYDrP5hFH6dRccf",
	"2lW2CvroGplevumn+E1HO8alV+p11P1GShmRRjPGkQmeaFfWBZV7zIkCc5cHXBXjV3PWle1pFNB7dyOs",
	"v9vOrpO6828yzIo9IS44kcureAGZ6cQfD46RfUclcG3MSnYHFD0QudA/b98C5sCP0S3KOczIpxGCg/kB",
	"uolMAsLTOIGjV6/f/OUmOkDon9ToqRIXgBPgUam1ohOt/shnvQxW9Q/n5H9haQJP8EkCpzg9Y7Fjpt4T",
	"miBWSJQxDghP1b8XGF9Fo6jgqapRyvx4MkkJ5viAGG/cauKYUYkNoqy61Un/Xadt1vYzpngOK5QJVAht",
	"3hYcnVyc39Ab+uFBiOPJBOfkgHBMD8qy/kuP4F9visPD1zHOyVj/1j9B/X31b3GW/HUyJXQyxWJhPlWm",
	"uc1oP4xJYnJ+/Jcb+qwV/qvq4wXmOAMJXBzf0DG61SXfHqP/N8NCLFoIRboxmibOkttj9HZZRqpQVbNK",
	"riq+PUaViagHuvSGqvJu6PWCCHT7fzC9YvEdyFsENMkZoRLhNGUPAt1ywKm2Nm5vqLJICmoXWysUlx4j",
	"Uv47iQEtmJCQ3FAs0e3fVFW3qk8oxhQVAmr1qaySxSwVtzdUMiSAJgjTBHGIgdwDSrDEIwQUT1MFEJjN",
	"SKzNVkyTG5qyh3GKJdB4iYjiMRyrlol20xRLAM/Er7Mr08boOFLMJIlUqjqyUL8HLgxCjw4ODw4VcFkO",
	"FOckOo5eHxweHEWjKMdyoTlocn80qa25zcHB+nPQQ2lXFYRZPy0EcMQeqGqWkoB6PM+T6Dj6CeRJnpcr",
	"fKquEiJao/QL7FJA/FkAX1byoXLYOPxZEK48ZmPamW0/rpjVR60jc0atD/Pq8LDkdutUKA1p0TD5w27B",
	"qcr7Zw4zNcyTap/RxG4ympQ91JKp2aurIo5BiFmRotXYqIl4Y6pvEr/FCit/FiCkoTlq0/xMhJYuykUA",
	"Km2DDfmbNvlJnqOEgUCUSQSfiJDiwEj7IsswX5pZqk9qVNrDH1Zrsx+1YSocgLCRDWwz9wHC7EpYYcJO",
	"IAj5liXLQdPh3tHQtYbZYRRq2aP45vLX/3l3eu3UqBXSPpjqRtFa3OBjW6m24KDDumaomjBvAvmxBdaj",
	"rxgd306j0OjuY0DHdhPnivg/28SnjM5SUpo9K0Y4bYLZxQij6NM4ZgnMgY5tD8ZTlizHVjLZnKrcmjyd",
	"5JzdEyWLx0Kk4xhK097JU1o/ABIi7WOnd5rySqRbY6QKKt0cYOmeFPKHX9GPOHjv1M4h2WCtT2i/W4Fk",
	"izAVIMf1lU8nPIVSF+WMzqoNXn1gvaoZA1vGq4lz+4S/M9WJ5/OzqJ7r6dG9ezKU8bI7PQC88sBgi3D8",
	"QpJH08oUXIEj8z3Y+DjT5CsA9hqjNWdjpRC0NapM5soYJck27NB9lEFnzfF3Go6OKZ3EC4jvvD6GTg23",
	"KGtbrHdtTrfiW9Q7uLfa6rQxp8FAUfqo3ErnV0glRTBmLm2GnYDNNrRg3/bG14evlGB/fXjUv5mxW0+u",
	"1dTI/L2pyzDoX66jc8sKciJEOkmIKFdp3DxiCUKcijNDaryKnRGob/ZWSVYj3yX3ZjKffJmp0QozeWYy",
	"D7N33st8cORtJnP3NM5s5OOFmTvbCB6c1WamPtF6z/BqmuvbkbojrGZnqj6okqZVUDoo4moE8xMZJKu9",
	"VoOskWeLZHoGrjYleoD6Q5p5HhzN/Ap3ttP0q85wPTYV8W7qyA0ibfaYUGNm+pRhNUHROltNirW1YucM",
	"11aA+6bYrD2/M2vFTzHH9cXt8Ene0E7076ff3xBvA1e/Ndf2LayuQEpC5wHQqu8NaGFLW1t2sWAsyj31",
	"ky9mJ+Jjh/FlFzdXefo199ru/pYC/3oTa+QzERk3K5TgNgFEZfn/sAFaNsDaRDtB6AFWebjIaxZoigAD",
	"wJgcw2z32lrrzkZCqpNZ+7vOmti56TEPa5CYfEm0VzCxR+smX6bmd8IeaMpw0iF3LAUyWXXlvaLH5nlr",
	"Dvh9GxSNej0U1RV3VclgF6W/tmk5GI76pttyiTbU6Smhdy9XoZ85IDyQfcJ96iD+MIsIphm7yxv2ggN3",
	"jT+c+F4nflOcTWoHoL2K3NIE4e0nkG9tkfsni59dNIaYD+XZ9f01Iur4cYC0J7AxwBgwbvremgLfk5xz",
	"hVc20Jn6JPSY5AFeLcn1qQ0S96HoPL/SdC/Ti93QbHMeuP5eNtqdX1joDPCPOeBkzGi6DICmokWKtn8l",
	"2JwD/xFg2Q/gXJYTOwA4n4GzcWLPnAeAR9Gjkr4PQH+vn3j/AaK9ANHf6xMcCKRgJzIPXJY9yfO3y1+w",
	"CzV+e0cubA0M2XY8o92jz/HY6UQLLNAUgCJRTM2xXj0Nr7xzppubHDxn6KD05VxrTI+jTZZfw1Zfh89r",
	"t8W8U15U++6k3V8GdmxNtShw8/nEHryacBAS846tZ5IhSxPC+ZeG1CwYb8L0ZXt2jOufaVqva4PtZuqe",
	"6VxdSOKZzIJTfScJR2w2M3X0Tel1wenm89mscZvTuo1dhavhap9Xr28JNGQhm/8uQXf4aK3rh9VvPQgb",
	"bHPYJZQ6UDR4i4MZUy+eq3vL/UrM0DQuuu1TXOVF6S9Tc5W92+NDmo05DRZ/1W2WPUc4gyOCocsfT4mS",
	"Jz02unb1ZvcxUE0cvPnZLs4MPfq5rzFI31JK745nlasT0auF8ZnMO0XhTOYh2ybey/xbir7nXfPebjAT",
	"azRC5yV7jVcLanfZBl2a67wtqn0pqhog50FALMSD7z2F8i5I942kCjK++28DbgZaWJH7Mlfnf7LcNXwR",
	"KmD7uhEgm2xf32um3M55oM0hXVdwK8oal4QquvKOyWc68O1htB7eH8Tde8mipyt+G66DK14N1MQcSsPJ",
	"ty6j0oMMzUtN+o0NzT1l/zDrdZDZqudtrdN7esK997zeCqPDOaYGcC/LwH35RpnXYjUk9WARe6CQoOlS",
	"c4zHfX9nCh4einoqbrlasIeyL1MsIEGMIgGYxwtU3ujkut7JkESD6jJxweqpr1EEn3CWpxAdH/374ZvD",
	"V//x+ugvnupsTLVVWxXwal/RkmxWF9Cks6bt2uUJlrjr1QeQ+MyStCzZrkshe65H3ejax8ZtHKpRH1+O",
	"jdzi5+DYTWpfz/CKCkUwKMin3+PYIZWqhYTuhSA0hgZbOblVUe1MUFGP5v4Cs4aeYEhmIDmJxSTOi05k",
	"xnmBuLnGdhBAT/OivP12xyw/A9Cyslr/vhaqWxP/XVAtB3V/0dpGVA20Zfd6cZtBxviyE7qGZCP0/qyz",
	"7gWAm738geFnwbATWpvA2L65ObZ3y3bieY12I2D/Ysq4NEXsBcA93f6B9GdBejfovgbykmMq7LsTvZgv",
	"iYeD3iL+2hawV5Bf7/UPzD8r5j2g2wT0qwo6sG5pNpLrVybvt0f3dkMfcV78Vt51seGLGNt7ByNkpVBH",
	"0vuaTP2vnKvp874x6okIj6Ii+D4Qx6ui2pTZp1F+QcuubpYfImDqD3p5JUtJNEikXFZP3eyUqszxvKqr",
	"/lCZ64kBhequGle3xh+N+uPF1bOQgdVr4sD6D0fPrKVty/eXedZQHRz66lvfHHB12ALTOVykmL6EfXTV",
	"W5PdS46W7qm3EOzfIr1Gg+7v4K3COpMB7KtOGe+7mypP2bLiiN5leUNnXirdBLv6rvCkzP6NYdz5qItu",
	"45g3xN1TbmGxNfkY6UVc59JEW32B3SCif1/oWgk+5JunCfuBb+mQqrP3BQNDuzfYz4pUkhxzOZkxno3L",
	"1WAf/mbE987jwfwzUqnm4KFt/mpP5pRQrG2XbuGvi3eL/qfkKjPB3wFT1ZHsYKzH+hN/Gq/6cb8PHxWG",
	"9FPlFsbVA3nOF+QiRW8Lb70MeA98KRe6e/rNPQ18eyFt+baf+tW2kG0nygfbahlsBxwrx/a87pqJYLOt",
	"TvM66tIX6TlzmX0+jiz2wTN3pvL5r1a2y8o7a2dbhbs+Pv4jAAD//+PEsge+kAAA",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
